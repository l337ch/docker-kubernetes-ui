var componentNamespaces = ["kubernetesApp.components.dashboard", "kubernetesApp.components.graph"];
// APP START
// ****************************
// /www/app/assets/app.js is autogenerated. Do not modify.
// Changes should be made in /master/modules/js or /master/components/<component-name>/js
// ****************************
// -----------------------------------

var app = angular.module('kubernetesApp', [
  'ngRoute',
  'ngMaterial',
  'ngLodash',
  'door3.css',
  'kubernetesApp.config',
  'kubernetesApp.services',
  'angular.filter'
].concat(componentNamespaces));

angular.module('kubernetesApp.config', []);
angular.module('kubernetesApp.services', ['kubernetesApp.config']);

app.config([
  '$routeProvider',
  function($routeProvider) {
    $routeProvider.when("/404", {templateUrl: "/views/partials/404.html"})
        // else 404
        .otherwise({redirectTo: "/404"});
  }
])
    .config([
      '$routeProvider',
      'manifestRoutes',
      function($routeProvider, manifestRoutes) {
        angular.forEach(manifestRoutes, function(r) {
          var route = {
            templateUrl: r.templateUrl
          };
          if (r.controller) {
            route.controller = r.controller;
          }
          if (r.css) {
            route.css = r.css;
          }
          $routeProvider.when(r.url, route);
        });
      }
    ]);

app.directive('includeReplace',
              function() {
                'use strict';
                return {
                  require: 'ngInclude',
                  restrict: 'A', /* optional */
                  link: function(scope, el, attrs) { el.replaceWith(el.children()); }
                };
              })
    .directive('compile',
               ["$compile", function($compile) {
                 'use strict';
                 return function(scope, element, attrs) {
                   scope.$watch(function(scope) { return scope.$eval(attrs.compile); },
                                function(value) {
                                  element.html(value);
                                  $compile(element.contents())(scope);
                                });
                 };
               }])
    .directive("kubernetesUiMenu",
               function() {
                 'use strict';
                 return {
                   templateUrl: "/views/partials/kubernetes-ui-menu.tmpl.html"
                 };
               })
    .directive('menuToggle', function() {
      'use strict';
      return {
        scope: {section: '='},
        templateUrl: '/views/partials/menu-toggle.tmpl.html',
        link: function($scope, $element) {
          var controller = $element.parent().controller();

          $scope.isOpen = function() { return controller.isOpen($scope.section); };
          $scope.toggle = function() { controller.toggleOpen($scope.section); };

          var parentNode = $element[0].parentNode.parentNode.parentNode;
          if (parentNode.classList.contains('parent-list-item')) {
            var heading = parentNode.querySelector('h2');
            $element[0].firstChild.setAttribute('aria-describedby', heading.id);
          }
        }
      };
    });

app.filter('startFrom',
           function() {
             'use strict';
             return function(input, start) { return input.slice(start); };
           })
    .filter('nospace', function() {
      'use strict';
      return function(value) { return (!value) ? '' : value.replace(/ /g, ''); };
    });

app.run(['$route', angular.noop])
    .run(["lodash", function(lodash) {
      // Alias lodash
      window['_'] = lodash;
    }]);

app.service('SidebarService', [
  '$rootScope',
  function($rootScope) {
    var service = this;
    service.sidebarItems = [];

    service.clearSidebarItems = function() { service.sidebarItems = []; };

    service.renderSidebar = function() {
      var _entries = '';
      service.sidebarItems.forEach(function(entry) { _entries += entry.Html; });

      if (_entries) {
        $rootScope.sidenavLeft = '<div layout="column">' + _entries + '</div>';
      }
    };

    service.addSidebarItem = function(item) {

      service.sidebarItems.push(item);

      service.sidebarItems.sort(function(a, b) { return (a.order > b.order) ? 1 : ((b.order > a.order) ? -1 : 0); });
    };
  }
]);


app.value("tabs", [{"component":"dashboard","title":"Dashboard"},{"component":"graph","title":"Graph"}]);
app.constant("manifestRoutes", [{"description":"Dashboard visualization.","url":"/dashboard/","templateUrl":"/components/dashboard/pages/home.html"},{"description":"Pods","url":"/dashboard/pods","templateUrl":"/components/dashboard/views/listPods.html"},{"description":"Pod Visualizer","url":"/dashboard/visualpods","templateUrl":"/components/dashboard/views/listPodsVisualizer.html"},{"description":"Services","url":"/dashboard/services","templateUrl":"/components/dashboard/views/listServices.html"},{"description":"Replication Controllers","url":"/dashboard/replicationcontrollers","templateUrl":"/components/dashboard/views/listReplicationControllers.html"},{"description":"Events","url":"/dashboard/events","templateUrl":"/components/dashboard/views/listEvents.html"},{"description":"Minions","url":"/dashboard/minions","templateUrl":"/components/dashboard/views/listMinions.html"},{"description":"Replication Controller","url":"/dashboard/replicationcontrollers/:replicationControllerId","templateUrl":"/components/dashboard/views/replication.html"},{"description":"Service","url":"/dashboard/services/:serviceId","templateUrl":"/components/dashboard/views/service.html"},{"description":"Explore","url":"/dashboard/groups/:grouping*?/selector/:selector*?","templateUrl":"/components/dashboard/views/groups.html"},{"description":"Pod","url":"/dashboard/pods/:podId","templateUrl":"/components/dashboard/views/pod.html"},{"description":"Force-directed graph visualization.","url":"/graph/","templateUrl":"/components/graph/pages/home.html"},{"description":"Inspection panel with detailed information about Kubernetes cluster entities.","url":"/graph/inspect","templateUrl":"/components/graph/pages/inspect.html","css":"/components/graph/css/show-details-table.css"}]);

angular.module("kubernetesApp.config", [])

.constant("ENV", {
	"/": {
		"k8sApiServer": "http://172.16.1.102:8080/api/v1beta2",
		"k8sDataServer": "http://172.16.1.102:5555/cluster",
		"k8sDataPollMinIntervalSec": 10,
		"k8sDataPollMaxIntervalSec": 120,
		"k8sDataPollErrorThreshold": 5,
		"cAdvisorProxy": "",
		"cAdvisorPort": "4194"
	}
})

.constant("ngConstant", true)

;
/**=========================================================
 * Module: config.js
 * App routes and resources configuration
 =========================================================*/
/**=========================================================
 * Module: constants.js
 * Define constants to inject across the application
 =========================================================*/
/**=========================================================
 * Module: main.js
 * Main Application Controller
 =========================================================*/
/**=========================================================
 * Module: tabs-global.js
 * Page Controller
 =========================================================*/

app.controller('TabCtrl', [
  '$scope',
  '$location',
  'tabs',
  function($scope, $location, tabs) {
    $scope.tabs = tabs;

    $scope.switchTab = function(index) {
      var location_path = $location.path();
      var tab = tabs[index];

      if (tab) {
        var path = '/%s'.format(tab.component);
        if (location_path.indexOf(path) == -1) {
          $location.path(path);
        }
      }
    };
  }
]);

/**=========================================================
 * Module: sidebar.js
 * Wraps the sidebar and handles collapsed state
 =========================================================*/
(function() {
  "use strict";

  angular.module('kubernetesApp.services')
      .service('cAdvisorService', ["$http", "$q", "ENV", function($http, $q, ENV) {
        var _baseUrl = function(minionIp) {
          var minionPort = ENV['/']['cAdvisorPort'] || "8081";
          var proxy = ENV['/']['cAdvisorProxy'] || "";

          return proxy + 'http://' + minionIp + ':' + minionPort + '/api/v1.0/';
        };

        this.getMachineInfo = getMachineInfo;

        function getMachineInfo(minionIp) {
          var fullUrl = _baseUrl(minionIp) + 'machine';
          var deferred = $q.defer();

          // hack
          $http.get(fullUrl).success(function(data) {
            deferred.resolve(data);
          }).error(function(data, status) { deferred.reject('There was an error') });
          return deferred.promise;
        }

        this.getContainerInfo = getContainerInfo;
        // containerId optional
        function getContainerInfo(minionIp, containerId) {
          containerId = (typeof containerId === "undefined") ? "/" : containerId;

          var fullUrl = _baseUrl(minionIp) + 'containers' + containerId;
          var deferred = $q.defer();

          var request = {
            "num_stats": 10,
            "num_samples": 0
          };

          $http.post(fullUrl, request)
              .success(function(data) { deferred.resolve(data); })
              .error(function() { deferred.reject('There was an error') });
          return deferred.promise;
        }

        this.getDataForMinion = function(minionIp) {
          var machineData, containerData;
          var deferred = $q.defer();

          var p = $q.all([getMachineInfo(minionIp), getContainerInfo(minionIp)])
                      .then(
                          function(dataArray) {
                            machineData = dataArray[0];
                            containerData = dataArray[1];

                            var memoryData = parseMemory(machineData, containerData);
                            var cpuData = parseCpu(machineData, containerData);
                            var fsData = parseFilesystems(machineData, containerData);
                            deferred.resolve({
                              memoryData: memoryData,
                              cpuData: cpuData,
                              filesystemData: fsData,
                              machineData: machineData,
                              containerData: containerData
                            });

                          },
                          function(errorData) { deferred.reject(errorData); });

          return deferred.promise;
        };

        // Utils to process cadvisor data
        function humanize(num, size, units) {
          var unit;
          for (unit = units.pop(); units.length && num >= size; unit = units.pop()) {
            num /= size;
          }
          return [num, unit];
        }

        // Following the IEC naming convention
        function humanizeIEC(num) {
          var ret = humanize(num, 1024, ["TiB", "GiB", "MiB", "KiB", "Bytes"]);
          return ret[0].toFixed(2) + " " + ret[1];
        }

        // Following the Metric naming convention
        function humanizeMetric(num) {
          var ret = humanize(num, 1000, ["TB", "GB", "MB", "KB", "Bytes"]);
          return ret[0].toFixed(2) + " " + ret[1];
        }

        function hasResource(stats, resource) { return stats.stats.length > 0 && stats.stats[0][resource]; }

        // Gets the length of the interval in nanoseconds.
        function getInterval(current, previous) {
          var cur = new Date(current);
          var prev = new Date(previous);

          // ms -> ns.
          return (cur.getTime() - prev.getTime()) * 1000000;
        }

        function parseCpu(machineInfo, containerInfo) {
          var cur = containerInfo.stats[containerInfo.stats.length - 1];
          var results = [];

          var cpuUsage = 0;
          if (containerInfo.spec.has_cpu && containerInfo.stats.length >= 2) {
            var prev = containerInfo.stats[containerInfo.stats.length - 2];
            var rawUsage = cur.cpu.usage.total - prev.cpu.usage.total;
            var intervalInNs = getInterval(cur.timestamp, prev.timestamp);

            // Convert to millicores and take the percentage
            cpuUsage = Math.round(((rawUsage / intervalInNs) / machineInfo.num_cores) * 100);
            if (cpuUsage > 100) {
              cpuUsage = 100;
            }
          }

          return {
            cpuPercentUsage: cpuUsage
          };
        }

        function parseFilesystems(machineInfo, containerInfo) {
          var cur = containerInfo.stats[containerInfo.stats.length - 1];
          if (!cur.filesystem) {
            return;
          }

          var filesystemData = [];
          for (var i = 0; i < cur.filesystem.length; i++) {
            var data = cur.filesystem[i];
            var totalUsage = Math.floor((data.usage * 100.0) / data.capacity);

            var f = {
              device: data.device,
              filesystemNumber: i + 1,
              usage: data.usage,
              usageDescription: humanizeMetric(data.usage),
              capacity: data.capacity,
              capacityDescription: humanizeMetric(data.capacity),
              totalUsage: Math.floor((data.usage * 100.0) / data.capacity)
            };

            filesystemData.push(f);
          }
          return filesystemData;
        }

        var oneMegabyte = 1024 * 1024;
        var oneGigabyte = 1024 * oneMegabyte;

        function parseMemory(machineInfo, containerInfo) {
          if (containerInfo.spec.has_memory && !hasResource(containerInfo, "memory")) {
            return;
          }

          // var titles = ["Time", "Total", "Hot"];
          var data = [];
          for (var i = 0; i < containerInfo.stats.length; i++) {
            var cur = containerInfo.stats[i];

            var elements = [];
            elements.push(cur.timestamp);
            elements.push(cur.memory.usage / oneMegabyte);
            elements.push(cur.memory.working_set / oneMegabyte);
            data.push(elements);
          }

          // Get the memory limit, saturate to the machine size.
          var memory_limit = machineInfo.memory_capacity;
          if (containerInfo.spec.memory.limit && (containerInfo.spec.memory.limit < memory_limit)) {
            memory_limit = containerInfo.spec.memory.limit;
          }

          var cur = containerInfo.stats[containerInfo.stats.length - 1];

          var r = {
            current: {
              memoryUsage: cur.memory.usage,
              workingMemoryUsage: cur.memory.working_set,
              memoryLimit: memory_limit,
              memoryUsageDescription: humanizeMetric(cur.memory.usage),
              workingMemoryUsageDescription: humanizeMetric(cur.memory.working_set),
              memoryLimitDescription: humanizeMetric(memory_limit)
            },
            historical: data
          };

          return r;
        }
      }]);
})();

app.provider('k8sApi',
             function() {

               var urlBase = '';

               this.setUrlBase = function(value) { urlBase = value; };

               var _get = function($http, baseUrl, query) {
                 var _fullUrl = baseUrl;
                 if (query !== undefined) {
                   _fullUrl += '/' + query;
                 }

                 return $http.get(_fullUrl);
               };

               this.$get = ["$http", "$q", function($http, $q) {
                 var api = {};

                 api.getUrlBase = function() { return urlBase; };

                 api.getPods = function(query) { return _get($http, urlBase + '/pods', query); };

                 api.getMinions = function(query) { return _get($http, urlBase + '/minions', query); };

                 api.getServices = function(query) { return _get($http, urlBase + '/services', query); };

                 api.getReplicationControllers = function(query) {
                   return _get($http, urlBase + '/replicationControllers', query)
                 };

                 api.getEvents = function(query) { return _get($http, urlBase + '/events', query); };

                 return api;
               }];
             })
    .config(["k8sApiProvider", "ENV", function(k8sApiProvider, ENV) {
      if (ENV && ENV['/'] && ENV['/']['k8sApiServer']) {
        var proxy = ENV['/']['cAdvisorProxy'] || '';
        k8sApiProvider.setUrlBase(proxy + ENV['/']['k8sApiServer']);
      }
    }]);

(function() {
  "use strict";

  var pollK8sDataServiceProvider = function PollK8sDataServiceProvider(_) {
    // A set of configuration controlling the polling behavior.
    // Their values should be configured in the application before
    // creating the service instance.

    var useSampleData = false;
    this.setUseSampleData = function(value) { useSampleData = value; };

    var sampleDataFiles = ["shared/assets/sampleData1.json"];
    this.setSampleDataFiles = function(value) { sampleDataFiles = value; };

    var dataServer = "http://localhost:5555/cluster";
    this.setDataServer = function(value) { dataServer = value; };

    var pollMinIntervalSec = 10;
    this.setPollMinIntervalSec = function(value) { pollMinIntervalSec = value; };

    var pollMaxIntervalSec = 120;
    this.setPollMaxIntervalSec = function(value) { pollMaxIntervalSec = value; };

    var pollErrorThreshold = 5;
    this.setPollErrorThreshold = function(value) { pollErrorThreshold = value; };

    this.$get = function($http, $timeout) {
      // Now the sequenceNumber will be used for debugging and verification purposes.
      var k8sdatamodel = {
        "data": undefined,
        "sequenceNumber": 0,
        "useSampleData": useSampleData
      };
      var pollingError = 0;
      var promise = undefined;

      // Implement fibonacci back off when the service is down.
      var pollInterval = pollMinIntervalSec;
      var pollIncrement = pollInterval;

      // Reset polling interval.
      var resetCounters = function() {
        pollInterval = pollMinIntervalSec;
        pollIncrement = pollInterval;
      };

      // Bump error count and polling interval.
      var bumpCounters = function() {
        // Bump the error count.
        pollingError++;

        // TODO: maybe display an error in the UI to the end user.
        if (pollingError % pollErrorThreshold === 0) {
          console.log("Error: " + pollingError + " consecutive polling errors for " + dataServer + ".");
        }

        // Bump the polling interval.
        var oldIncrement = pollIncrement;
        pollIncrement = pollInterval;
        pollInterval += oldIncrement;

        // Reset when limit reached.
        if (pollInterval > pollMaxIntervalSec) {
          resetCounters();
        }
      };

      var updateModel = function(newModel) {
        var dedupe = function(dataModel) {
          if (dataModel.resources) {
            dataModel.resources = _.uniq(dataModel.resources, function(resource) { return resource.id; });
          }

          if (dataModel.relations) {
            dataModel.relations =
                _.uniq(dataModel.relations, function(relation) { return relation.source + relation.target; });
          }
        };

        dedupe(newModel);

        var newModelString = JSON.stringify(newModel);
        var oldModelString = "";
        if (k8sdatamodel.data) {
          oldModelString = JSON.stringify(k8sdatamodel.data);
        }

        if (newModelString !== oldModelString) {
          k8sdatamodel.data = newModel;
          k8sdatamodel.sequenceNumber++;
        }

        pollingError = 0;
        resetCounters();
      };

      var nextSampleDataFile = 0;
      var getSampleDataFile = function() {
        var result = "";
        if (sampleDataFiles.length > 0) {
          result = sampleDataFiles[nextSampleDataFile % sampleDataFiles.length];
          ++nextSampleDataFile;
        }

        return result;
      };

      var pollOnce = function(scope, repeat) {
        var dataSource = (k8sdatamodel.useSampleData) ? getSampleDataFile() : dataServer;
        $.getJSON(dataSource)
            .done(function(newModel, jqxhr, textStatus) {
              if (newModel && newModel.success) {
                delete newModel.success;    // Remove success indicator.
                delete newModel.timestamp;  // Remove changing timestamp.
                updateModel(newModel);
                scope.$apply();
                promise = repeat ? $timeout(function() { pollOnce(scope, true); }, pollInterval * 1000) : undefined;
                return;
              }

              bumpCounters();
              promise = repeat ? $timeout(function() { pollOnce(scope, true); }, pollInterval * 1000) : undefined;
            })
            .fail(function(jqxhr, textStatus, error) {
              bumpCounters();
              promise = repeat ? $timeout(function() { pollOnce(scope, true); }, pollInterval * 1000) : undefined;
            });
      };

      var isPolling = function() { return promise ? true : false; };

      var start = function(scope) {
        // If polling has already started, then calling start() again would
        // just reset the counters and polling interval, but it will not
        // start a new thread polling in parallel to the existing polling
        // thread.
        resetCounters();
        if (!promise) {
          k8sdatamodel.data = undefined;
          pollOnce(scope, true);
        }
      };

      var stop = function() {
        if (promise) {
          $timeout.cancel(promise);
          promise = undefined;
        }
      };

      var refresh = function(scope) {
        stop(scope);
        resetCounters();
        k8sdatamodel.data = undefined;
        pollOnce(scope, false);
      };

      return {
        "k8sdatamodel": k8sdatamodel,
        "isPolling": isPolling,
        "refresh": refresh,
        "start": start,
        "stop": stop
      };
    };
  };

  angular.module("kubernetesApp.services")
      .provider("pollK8sDataService", ["lodash", pollK8sDataServiceProvider])
      .config(["pollK8sDataServiceProvider", "ENV", function(pollK8sDataServiceProvider, ENV) {
        if (ENV && ENV['/']) {
          if (ENV['/']['k8sDataServer']) {
            pollK8sDataServiceProvider.setDataServer(ENV['/']['k8sDataServer']);
          }
          if (ENV['/']['k8sDataPollIntervalMinSec']) {
            pollK8sDataServiceProvider.setPollIntervalSec(ENV['/']['k8sDataPollIntervalMinSec']);
          }
          if (ENV['/']['k8sDataPollIntervalMaxSec']) {
            pollK8sDataServiceProvider.setPollIntervalSec(ENV['/']['k8sDataPollIntervalMaxSec']);
          }
          if (ENV['/']['k8sDataPollErrorThreshold']) {
            pollK8sDataServiceProvider.setPollErrorThreshold(ENV['/']['k8sDataPollErrorThreshold']);
          }
        }
      }]);

}());

/**=========================================================
 * Module: toggle-state.js
 * Services to share toggle state functionality
 =========================================================*/


app.controller('cAdvisorController', [
  '$scope',
  '$routeParams',
  'k8sApi',
  'lodash',
  'cAdvisorService',
  '$q',
  '$interval',
  function($scope, $routeParams, k8sApi, lodash, cAdvisorService, $q, $interval) {
    $scope.k8sApi = k8sApi;

    $scope.activeMinionDataById = {};
    $scope.maxDataByById = {};

    $scope.getData = function() {
      $scope.loading = true;

      k8sApi.getMinions().success(angular.bind(this, function(res) {
        $scope.minions = res;

        var promises = lodash.map(res.items, function(m) { return cAdvisorService.getDataForMinion(m.hostIP); });

        $q.all(promises).then(
            function(dataArray) {
              lodash.each(dataArray, function(data, i) {
                var m = res.items[i];
                var maxData = maxMemCpuInfo(m.id, data.memoryData, data.cpuData, data.filesystemData);

                // console.log("maxData", maxData);

                $scope.activeMinionDataById[m.id] =
                    transformMemCpuInfo(data.memoryData, data.cpuData, data.filesystemData, maxData, m.hostIP)
              });

            },
            function(errorData) {
              // console.log("Error: " + errorData);
              $scope.loading = false;
            });

        $scope.loading = false;
      })).error(angular.bind(this, this.handleError));
    };

    function getcAdvisorDataForMinion(m) {
      var p = cAdvisorService.getDataForMinion(m.hostIP);
      return p;
    }

    function handleError(data, status, headers, config) {
      // console.log("Error (" + status + "): " + data);
      $scope.loading = false;
    };

    // d3
    function getColorForIndex(i, percentage) {
      // var colors = ['red', 'blue', 'yellow', 'pink', 'purple', 'green', 'orange'];
      // return colors[i];
      var c = "color-" + (i + 1);
      if (percentage && percentage >= 90)
        c = c + ' color-critical';
      else if (percentage && percentage >= 80)
        c = c + ' color-warning';

      return c;
    }

    function getMaxColorForIndex(i, percentage) {
      // var colors = ['red', 'blue', 'yellow', 'pink', 'purple', 'green', 'orange'];
      // return colors[i];
      var c = "color-max-" + (i + 1);
      if (percentage && percentage >= 90)
        c = c + ' color-max-critical';
      else if (percentage && percentage >= 80)
        c = c + ' color-max-warning';

      return c;
    }

    function maxMemCpuInfo(mId, mem, cpu, fsDataArray) {
      if ($scope.maxDataByById[mId] === undefined) $scope.maxDataByById[mId] = {};

      var currentMem = mem.current;
      var currentCpu = cpu;

      var items = [];

      if ($scope.maxDataByById[mId]['cpu'] === undefined ||
          $scope.maxDataByById[mId]['cpu'] < currentCpu.cpuPercentUsage) {
        // console.log("New max cpu " + mId, $scope.maxDataByById[mId].cpu, currentCpu.cpuPercentUsage);
        $scope.maxDataByById[mId]['cpu'] = currentCpu.cpuPercentUsage;
      }
      items.push({
        maxValue: $scope.maxDataByById[mId]['cpu'],
        maxTickClassNames: getColorForIndex(0, $scope.maxDataByById[mId]['cpu']),
        maxClassNames: getMaxColorForIndex(0, $scope.maxDataByById[mId]['cpu'])
      });

      var memPercentage = Math.floor((currentMem.memoryUsage * 100.0) / currentMem.memoryLimit);
      if ($scope.maxDataByById[mId]['mem'] === undefined || $scope.maxDataByById[mId]['mem'] < memPercentage)
        $scope.maxDataByById[mId]['mem'] = memPercentage;
      items.push({
        maxValue: $scope.maxDataByById[mId]['mem'],
        maxTickClassNames: getColorForIndex(1, $scope.maxDataByById[mId]['mem']),
        maxClassNames: getMaxColorForIndex(1, $scope.maxDataByById[mId]['mem'])
      });

      for (var i = 0; i < fsDataArray.length; i++) {
        var f = fsDataArray[i];
        var fid = 'FS #' + f.filesystemNumber;
        if ($scope.maxDataByById[mId][fid] === undefined || $scope.maxDataByById[mId][fid] < f.totalUsage)
          $scope.maxDataByById[mId][fid] = f.totalUsage;
        items.push({
          maxValue: $scope.maxDataByById[mId][fid],
          maxTickClassNames: getColorForIndex(2 + i, $scope.maxDataByById[mId][fid]),
          maxClassNames: getMaxColorForIndex(2 + i, $scope.maxDataByById[mId][fid])
        });
      }

      // console.log("Max Data is now " + mId, $scope.maxDataByById[mId]);
      return items;
    }

    function transformMemCpuInfo(mem, cpu, fsDataArray, maxData, hostName) {
      var currentMem = mem.current;
      var currentCpu = cpu;

      var items = [];

      items.push({
        label: 'CPU',
        stats: currentCpu.cpuPercentUsage + '%',
        value: currentCpu.cpuPercentUsage,
        classNames: getColorForIndex(0, currentCpu.cpuPercentUsage),
        maxData: maxData[0],
        hostName: hostName
      });

      var memPercentage = Math.floor((currentMem.memoryUsage * 100.0) / currentMem.memoryLimit);
      items.push({
        label: 'Memory',
        stats: currentMem.memoryUsageDescription + ' / ' + currentMem.memoryLimitDescription,
        value: memPercentage,
        classNames: getColorForIndex(1, memPercentage),
        maxData: maxData[1],
        hostName: hostName
      });

      for (var i = 0; i < fsDataArray.length; i++) {
        var f = fsDataArray[i];

        items.push({
          label: 'FS #' + f.filesystemNumber,
          stats: f.usageDescription + ' / ' + f.capacityDescription,
          value: f.totalUsage,
          classNames: getColorForIndex(2 + i, f.totalUsage),
          maxData: maxData[2 + i],
          hostName: hostName

        });
      }

      var a = [];
      var segments = {
        segments: items
      };
      a.push(segments);
      return a;
    };

    // end d3
    var promise = $interval($scope.getData, 3000);

    // Cancel interval on page changes
    $scope.$on('$destroy', function() {
      if (angular.isDefined(promise)) {
        $interval.cancel(promise);
        promise = undefined;
      }
    });

    $scope.getData();

  }
]);
/**=========================================================
 * Module: Dashboard
 * Visualizer for clusters
 =========================================================*/

app.controller('DashboardCtrl', ['$scope', function($scope) {}]);

/**=========================================================
 * Module: Group
 * Visualizer for groups
 =========================================================*/

app.controller('GroupCtrl', [
  '$scope',
  '$route',
  '$interval',
  '$routeParams',
  'k8sApi',
  '$rootScope',
  '$location',
  'lodash',
  function($scope, $route, $interval, $routeParams, k8sApi, $rootScope, $location, _) {
    'use strict';
    $scope.doTheBack = function() { window.history.back(); };

    $scope.capitalize = function(s) { return _.capitalize(s); };

    $rootScope.doTheBack = $scope.doTheBack;

    $scope.resetGroupLayout = function(group) { delete group.settings; };

    $scope.handlePath = function(path) {
      var parts = path.split("/");
      // split leaves an empty string at the beginning.
      parts = parts.slice(1);

      if (parts.length === 0) {
        return;
      }
      this.handleGroups(parts.slice(1));
    };

    $scope.getState = function(obj) { return Object.keys(obj)[0]; };

    $scope.clearSelector = function(grouping) { $location.path("/dashboard/groups/" + grouping + "/selector/"); };

    $scope.changeGroupBy = function() {
      var grouping = $scope.selectedGroupBy;

      var s = _.clone($location.search());
      if ($scope.routeParams.grouping != grouping)
        $location.path("/dashboard/groups/" + grouping + "/selector/").search(s);
    };

    $scope.createBarrier = function(count, callback) {
      var barrier = count;
      var barrierFunction = angular.bind(this, function(data) {
        // JavaScript is single threaded so this is safe.
        barrier--;
        if (barrier === 0) {
          if (callback) {
            callback();
          }
        }
      });
      return barrierFunction;
    };

    $scope.handleGroups = function(parts, selector) {
      $scope.groupBy = parts;
      $scope.loading = true;
      $scope.selector = selector;
      var args = [];
      var type = "";
      if (selector && selector.length > 0) {
        $scope.selectorPieces = selector.split(",");
        var labels = [];
        var fields = [];
        for (var i = 0; i < $scope.selectorPieces.length; i++) {
          var piece = $scope.selectorPieces[i];
          if (piece[0] == '$') {
            fields.push(piece.slice(2));
          } else {
            if (piece.indexOf("type=") === 0) {
              var labelParts = piece.split("=");
              if (labelParts.length > 1) {
                type = labelParts[1];
              }
            } else {
              labels.push(piece);
            }
          }
        }
        if (labels.length > 0) {
          args.push("labels=" + encodeURI(labels.join(",")));
        }
        if (fields.length > 0) {
          args.push("fields=" + encodeURI(fields.join(",")));
        }
      }
      var query = "?" + args.join("&");
      var list = [];
      var count = type.length > 0 ? 1 : 3;
      var barrier = $scope.createBarrier(count, function() {
        $scope.groups = $scope.groupData(list, 0);
        $scope.loading = false;
        $scope.groupByOptions = buildGroupByOptions();
        $scope.selectedGroupBy = $routeParams.grouping;
      });

      if (type === "" || type == "pod") {
        k8sApi.getPods(query).success(function(data) {
          $scope.addLabel("type", "pod", data.items);
          for (var i = 0; data.items && i < data.items.length; ++i) {
            data.items[i].labels.host = data.items[i].currentState.host;
            list.push(data.items[i]);
          }
          barrier();
        }).error($scope.handleError);
      }
      if (type === "" || type == "service") {
        k8sApi.getServices(query).success(function(data) {
          $scope.addLabel("type", "service", data.items);
          for (var i = 0; data.items && i < data.items.length; ++i) {
            list.push(data.items[i]);
          }
          barrier();
        }).error($scope.handleError);
      }
      if (type === "" || type == "replicationController") {
        k8sApi.getReplicationControllers(query).success(angular.bind(this, function(data) {
          $scope.addLabel("type", "replicationController", data.items);
          for (var i = 0; data.items && i < data.items.length; ++i) {
            list.push(data.items[i]);
          }
          barrier();
        })).error($scope.handleError);
      }
    };

    $scope.addLabel = function(key, value, items) {
      if (!items) {
        return;
      }
      for (var i = 0; i < items.length; i++) {
        if (!items[i].labels) {
          items[i].labels = [];
        }
        items[i].labels[key] = value;
      }
    };

    $scope.groupData = function(items, index) {
      var result = {
        "items": {},
        "kind": "grouping"
      };
      for (var i = 0; i < items.length; i++) {
        key = items[i].labels[$scope.groupBy[index]];
        if (!key) {
          key = "";
        }
        var list = result.items[key];
        if (!list) {
          list = [];
          result.items[key] = list;
        }
        list.push(items[i]);
      }

      if (index + 1 < $scope.groupBy.length) {
        for (var key in result.items) {
          result.items[key] = $scope.groupData(result.items[key], index + 1);
        }
      }
      return result;
    };
    $scope.getGroupColor = function(type) {
      if (type === 'pod') {
        return '#6193F0';
      } else if (type === 'replicationController') {
        return '#E008FE';
      } else if (type === 'service') {
        return '#7C43FF';
      }
    };

    var groups = $routeParams.grouping;
    if (!groups) {
      groups = '';
    }

    $scope.routeParams = $routeParams;
    $scope.route = $route;

    $scope.handleGroups(groups.split('/'), $routeParams.selector);

    $scope.handleError = function(data, status, headers, config) {
      console.log("Error (" + status + "): " + data);
      $scope_.loading = false;
    };

    function getDefaultGroupByOptions() { return [{name: 'Type', value: 'type'}, {name: 'Name', value: 'name'}]; }

    function buildGroupByOptions() {
      var g = $scope.groups;
      var options = getDefaultGroupByOptions();
      var newOptions = _.map(g.items, function(vals) { return _.map(vals, function(v) { return _.keys(v.labels); }); });
      newOptions =
          _.reject(_.uniq(_.flattenDeep(newOptions)), function(o) { return o == 'name' || o == 'type' || o == ""; });
      newOptions = _.map(newOptions, function(o) {
        return {
          name: o,
          value: o
        };
      });

      options = options.concat(newOptions);
      return options;
    }

    $scope.changeFilterBy = function(selector) {
      var grouping = $scope.selectedGroupBy;

      var s = _.clone($location.search());
      if ($scope.routeParams.selector != selector)
        $location.path("/dashboard/groups/" + $scope.routeParams.grouping + "/selector/" + selector).search(s);
    };
  }
]);

/**=========================================================
 * Module: Header
 * Visualizer for clusters
 =========================================================*/

angular.module('kubernetesApp.components.dashboard', [])
    .controller('HeaderCtrl', [
      '$scope',
      '$location',
      function($scope, $location) {
        'use strict';
        $scope.$watch('Pages', function(newValue, oldValue) {
          if (typeof newValue !== 'undefined') {
            $location.path(newValue);
          }
        });

        $scope.subPages = [
          {category: 'dashboard', name: 'Explore', value: '/dashboard/groups/type/selector/'},
          {category: 'dashboard', name: 'Pods', value: '/dashboard/pods'},
          {category: 'dashboard', name: 'Minions', value: '/dashboard/minions'},
          {category: 'dashboard', name: 'Replication Controllers', value: '/dashboard/replicationcontrollers'},
          {category: 'dashboard', name: 'Services', value: '/dashboard/services'},
          {category: 'dashboard', name: 'Events', value: '/dashboard/events'}
        ];
      }
    ]);

/**=========================================================
 * Module: List Events
 * Visualizer list events
 =========================================================*/

app.controller('ListEventsCtrl', [
  '$scope',
  '$routeParams',
  'k8sApi',
  '$location',
  '$filter',
  function($scope, $routeParams, k8sApi, $location, $filter) {
    'use strict';
    $scope.getData = getData;
    $scope.loading = true;
    $scope.k8sApi = k8sApi;
    $scope.pods = null;
    $scope.groupedPods = null;
    $scope.serverView = false;

    $scope.headers = [
      {name: 'Time', field: 'time'},
      {name: 'From', field: 'from'},
      {name: 'Sub Object Path', field: 'subobject'},
      {name: 'Reason', field: 'reason'},
      {name: 'Message', field: 'message'}
    ];

    $scope.custom = {
      time: '',
      from: 'grey',
      subobject: 'grey',
      reason: 'grey',
      message: 'grey'
    };
    $scope.sortable = ['time', 'from', 'subobject'];
    $scope.thumbs = 'thumb';
    $scope.count = 10;

    $scope.go = function(d) { $location.path('/dashboard/pods/' + d.id); };

    $scope.moreClick = function(d, e) {
      $location.path('/dashboard/pods/' + d.id);
      e.stopPropagation();
    };

    function handleError(data, status, headers, config) {
      console.log("Error (" + status + "): " + data);
      $scope.loading = false;
    }

    $scope.content = [];

    function getData(dataId) {
      $scope.loading = true;
      k8sApi.getEvents().success(function(data) {
        $scope.loading = false;

        var _fixComma = function(str) {
          if (str.substring(0, 1) == ',') {
            return str.substring(1);
          } else {
            return str;
          }
        };

        data.items.forEach(function(event) {

          $scope.content.push({
            time: $filter('date')(event.timestamp, 'medium'),
            from: event.source,
            subobject: event.involvedObject.fieldPath,
            reason: event.reason,
            message: event.message
          });

        });

      }).error($scope.handleError);
    }

    getData($routeParams.serviceId);

  }
]);

/**=========================================================
 * Module: Minions
 * Visualizer for minions
 =========================================================*/

app.controller('ListMinionsCtrl', [
  '$scope',
  '$routeParams',
  'k8sApi',
  '$location',
  function($scope, $routeParams, k8sApi, $location) {
    'use strict';
    $scope.getData = getData;
    $scope.loading = true;
    $scope.k8sApi = k8sApi;
    $scope.pods = null;
    $scope.groupedPods = null;
    $scope.serverView = false;

    $scope.headers = [{name: 'Name', field: 'name'}, {name: 'IP', field: 'ip'}, {name: 'Status', field: 'status'}];

    $scope.custom = {
      name: '',
      status: 'grey',
      ip: 'grey'
    };
    $scope.sortable = ['name', 'status', 'ip'];
    $scope.thumbs = 'thumb';
    $scope.count = 10;

    $scope.go = function(d) { $location.path('/dashboard/pods/' + d.id); };

    $scope.moreClick = function(d, e) {
      $location.path('/dashboard/pods/' + d.id);
      e.stopPropagation();
    };

    function handleError(data, status, headers, config) {
      console.log("Error (" + status + "): " + data);
      $scope.loading = false;
    }

    $scope.content = [];

    function getData(dataId) {
      $scope.loading = true;
      k8sApi.getMinions().success(function(data) {
        $scope.loading = false;

        var _fixComma = function(str) {
          if (str.substring(0, 1) == ',') {
            return str.substring(1);
          } else {
            return str;
          }
        };

        data.items.forEach(function(minion) {
          var _kind = '';

          if (minion.status.conditions) {
            Object.keys(minion.status.conditions)
                .forEach(function(key) { _kind += minion.status.conditions[key].kind; });
          }

          $scope.content.push({name: minion.id, ip: minion.hostIP, status: _kind});

        });

      }).error($scope.handleError);
    }

    getData($routeParams.serviceId);

  }
]);



app.controller('ListPodsCtrl', [
  '$scope',
  '$routeParams',
  'k8sApi',
  'lodash',
  '$location',
  function($scope, $routeParams, k8sApi, lodash, $location) {
    var _ = lodash;
    $scope.getData = getData;
    $scope.loading = true;
    $scope.k8sApi = k8sApi;
    $scope.pods = null;
    $scope.groupedPods = null;
    $scope.serverView = false;

    $scope.headers = [
      {name: '', field: 'thumb'},
      {name: 'Pod', field: 'pod'},
      {name: 'IP', field: 'ip'},
      {name: 'Status', field: 'status'},
      {name: 'Containers', field: 'containers'},
      {name: 'Images', field: 'images'},
      {name: 'Host', field: 'host'},
      {name: 'Labels', field: 'labels'}
    ];

    $scope.custom = {
      pod: '',
      ip: 'grey',
      containers: 'grey',
      images: 'grey',
      host: 'grey',
      labels: 'grey',
      status: 'grey'
    };
    $scope.sortable = ['pod', 'ip', 'status'];
    $scope.thumbs = 'thumb';
    $scope.count = 10;

    $scope.go = function(d) { $location.path('/dashboard/pods/' + d.id); };

    $scope.moreClick = function(d, e) {
      $location.path('/dashboard/pods/' + d.id);
      e.stopPropagation();
    };

    var orderedPodNames = [];

    function handleError(data, status, headers, config) {
      console.log("Error (" + status + "): " + data);
      $scope.loading = false;
    };

    function getPodName(pod) { return _.has(pod.labels, 'name') ? pod.labels.name : pod.id; }

    $scope.content = [];

    function getData(dataId) {
      $scope.loading = true;
      k8sApi.getPods().success(angular.bind(this, function(data) {
        $scope.loading = false;

        var _fixComma = function(str) {
          if (str.substring(0, 1) == ',') {
            return str.substring(1);
          } else {
            return str;
          }
        };

        data.items.forEach(function(pod) {
          var _containers = '', _images = '', _labels = '', _uses = '';

          if (pod.desiredState.manifest) {
            Object.keys(pod.desiredState.manifest.containers)
                .forEach(function(key) {
                  _containers += ', ' + pod.desiredState.manifest.containers[key].name;
                  _images += ', ' + pod.desiredState.manifest.containers[key].image;
                });
          }

          Object.keys(pod.labels)
              .forEach(function(key) {
                if (key == 'name') {
                  _labels += ', ' + pod.labels[key];
                }
                if (key == 'uses') {
                  _uses += ', ' + pod.labels[key];
                }
              });

          $scope.content.push({
            thumb: '"/assets/img/kubernetes.svg"',
            pod: pod.id,
            ip: pod.currentState.podIP,
            containers: _fixComma(_containers),
            images: _fixComma(_images),
            host: pod.currentState.host,
            labels: _fixComma(_labels) + ':' + _fixComma(_uses),
            status: pod.currentState.status
          });

        });

      })).error(angular.bind(this, handleError));
    };

    $scope.getPodRestarts = function(pod) {
      var r = null;
      var container = _.first(pod.desiredState.manifest.containers);
      if (container) r = pod.currentState.info[container.name].restartCount;
      return r;
    };

    $scope.otherLabels = function(labels) { return _.omit(labels, 'name') };

    $scope.podStatusClass = function(pod) {

      var s = pod.currentState.status.toLowerCase();

      if (s == 'running' || s == 'succeeded')
        return null;
      else
        return "status-" + s;
    };

    $scope.podIndexFromName = function(pod) {
      var name = getPodName(pod);
      return _.indexOf(orderedPodNames, name) + 1;
    };

    getData($routeParams.serviceId);

  }
]);

/**=========================================================
 * Module: Replication Controllers
 * Visualizer for replication controllers
 =========================================================*/

app.controller('ListReplicationControllersCtrl', [
  '$scope',
  '$routeParams',
  'k8sApi',
  '$location',
  function($scope, $routeParams, k8sApi, $location) {
    'use strict';
    $scope.getData = getData;
    $scope.loading = true;
    $scope.k8sApi = k8sApi;
    $scope.pods = null;
    $scope.groupedPods = null;
    $scope.serverView = false;

    $scope.headers = [
      {name: 'Controller', field: 'controller'},
      {name: 'Containers', field: 'containers'},
      {name: 'Images', field: 'images'},
      {name: 'Selector', field: 'selector'},
      {name: 'Replicas', field: 'replicas'}
    ];

    $scope.custom = {
      controller: '',
      containers: 'grey',
      images: 'grey',
      selector: 'grey',
      replicas: 'grey'
    };
    $scope.sortable = ['controller', 'containers', 'images'];
    $scope.thumbs = 'thumb';
    $scope.count = 10;

    $scope.go = function(d) { $location.path('/dashboard/pods/' + d.id); };

    $scope.moreClick = function(d, e) {
      $location.path('/dashboard/pods/' + d.id);
      e.stopPropagation();
    };

    function handleError(data, status, headers, config) {
      console.log("Error (" + status + "): " + data);
      $scope.loading = false;
    }

    $scope.content = [];

    function getData(dataId) {
      $scope.loading = true;
      k8sApi.getReplicationControllers().success(function(data) {
        $scope.loading = false;

        var _fixComma = function(str) {
          if (str.substring(0, 1) == ',') {
            return str.substring(1);
          } else {
            return str;
          }
        };

        data.items.forEach(function(replicationController) {

          var _name = '', _image = '';

          if (replicationController.desiredState.podTemplate.desiredState.manifest.containers) {
            Object.keys(replicationController.desiredState.podTemplate.desiredState.manifest.containers)
                .forEach(function(key) {
                  _name += replicationController.desiredState.podTemplate.desiredState.manifest.containers[key].name;
                  _image += replicationController.desiredState.podTemplate.desiredState.manifest.containers[key].image;
                });
          }

          var _name_selector = '';

          if (replicationController.desiredState.replicaSelector) {
            Object.keys(replicationController.desiredState.replicaSelector)
                .forEach(function(key) { _name_selector += replicationController.desiredState.replicaSelector[key]; });
          }

          $scope.content.push({
            controller: replicationController.id,
            containers: _name,
            images: _image,
            selector: _name_selector,
            replicas: replicationController.currentState.replicas
          });

        });

      }).error($scope.handleError);
    }

    getData($routeParams.serviceId);

  }
]);

/**=========================================================
 * Module: Services
 * Visualizer for services
 =========================================================*/

app.controller('ListServicesCtrl', [
  '$scope',
  '$interval',
  '$routeParams',
  'k8sApi',
  '$rootScope',
  function($scope, $interval, $routeParams, k8sApi, $rootScope) {
    'use strict';
    $scope.doTheBack = function() { window.history.back(); };

    $scope.headers = [
      {name: 'Name', field: 'name'},
      {name: 'Labels', field: 'labels'},
      {name: 'Selector', field: 'selector'},
      {name: 'IP', field: 'ip'},
      {name: 'Port', field: 'port'}
    ];

    $scope.custom = {
      name: '',
      ip: 'grey',
      selector: 'grey',
      port: 'grey',
      labels: 'grey'
    };
    $scope.sortable = ['name', 'ip', 'port'];
    $scope.count = 10;

    $scope.content = [];

    $rootScope.doTheBack = $scope.doTheBack;

    $scope.handleError = function(data, status, headers, config) {
      console.log("Error (" + status + "): " + data);
      $scope_.loading = false;
    };

    $scope.getData = function(dataId) {
      $scope.loading = true;
      k8sApi.getServices(dataId).success(angular.bind(this, function(data) {
        $scope.services = data;
        $scope.loading = false;

        var _fixComma = function(str) {
          if (str.substring(0, 1) == ',') {
            return str.substring(1);
          } else {
            return str;
          }
        };

        var addLabel = function(str, label) {
          if (str) {
            str = label + str;
          }
          return str;
        };

        if (data.items.constructor === Array) {
          data.items.forEach(function(service) {

            var _name = '', _uses = '', _component = '', _provider = '';

            if (service.labels !== null && typeof service.labels === 'object') {
              Object.keys(service.labels)
                  .forEach(function(key) {
                    if (key == 'name') {
                      _name += ',' + service.labels[key];
                    }
                    if (key == 'component') {
                      _component += ',' + service.labels[key];
                    }
                    if (key == 'provider') {
                      _provider += ',' + service.labels[key];
                    }
                  });
            }

            var _selectors = '';

            if (service.selector !== null && typeof service.selector === 'object') {
              Object.keys(service.selector)
                  .forEach(function(key) {
                    if (key == 'name') {
                      _selectors += ',' + service.selector[key];
                    }
                  });
            }

            $scope.content.push({
              name: service.id,
              ip: service.portalIP,
              port: service.port,
              selector: addLabel(_fixComma(_selectors), 'name='),
              labels: addLabel(_fixComma(_name), 'name=') + ' ' + addLabel(_fixComma(_component), 'component=') + ' ' +
                          addLabel(_fixComma(_provider), 'provider=')
            });
          });
        }
      })).error($scope.handleError);
    };

    $scope.getData($routeParams.serviceId);
  }
]);

/**=========================================================
 * Module: Pods
 * Visualizer for pods
 =========================================================*/

app.controller('PodCtrl', [
  '$scope',
  '$interval',
  '$routeParams',
  'k8sApi',
  '$rootScope',
  function($scope, $interval, $routeParams, k8sApi, $rootScope) {
    'use strict';
    $scope.doTheBack = function() { window.history.back(); };

    $rootScope.doTheBack = $scope.doTheBack;

    $scope.handleError = function(data, status, headers, config) {
      console.log("Error (" + status + "): " + data);
      $scope_.loading = false;
    };

    $scope.handlePod = function(podId) {
      $scope.loading = true;
      k8sApi.getPods(podId).success(angular.bind(this, function(data) {
        $scope.pod = data;
        $scope.loading = false;
      })).error($scope.handleError);
    };

    $scope.handlePod($routeParams.podId);
  }
]);

/**=========================================================
 * Module: Replication
 * Visualizer for replication controllers
 =========================================================*/

function ReplicationController() {
}

ReplicationController.prototype.getData = function(dataId) {
  this.scope.loading = true;
  this.k8sApi.getReplicationControllers(dataId).success(angular.bind(this, function(data) {
    this.scope.replicationController = data;
    this.scope.loading = false;
  })).error(angular.bind(this, this.handleError));
};

ReplicationController.prototype.handleError = function(data, status, headers, config) {
  console.log("Error (" + status + "): " + data);
  this.scope.loading = false;
};

app.controller('ReplicationControllerCtrl', [
  '$scope',
  '$routeParams',
  'k8sApi',
  function($scope, $routeParams, k8sApi) {
    $scope.controller = new ReplicationController();
    $scope.controller.k8sApi = k8sApi;
    $scope.controller.scope = $scope;
    $scope.controller.getData($routeParams.replicationControllerId);
  }
]);

/**=========================================================
 * Module: Services
 * Visualizer for services
 =========================================================*/

function ServiceController() {
}

ServiceController.prototype.getData = function(dataId) {
  this.scope.loading = true;
  this.k8sApi.getServices(dataId).success(angular.bind(this, function(data) {
    this.scope.service = data;
    this.scope.loading = false;
  })).error(angular.bind(this, this.handleError));
};

ServiceController.prototype.handleError = function(data, status, headers, config) {
  console.log("Error (" + status + "): " + data);
  this.scope.loading = false;
};

app.controller('ServiceCtrl', [
  '$scope',
  '$routeParams',
  'k8sApi',
  '$location',
  function($scope, $routeParams, k8sApi, $location) {
    $scope.controller = new ServiceController();
    $scope.controller.k8sApi = k8sApi;
    $scope.controller.scope = $scope;
    $scope.controller.getData($routeParams.serviceId);

    $scope.go = function(d) { $location.path('/dashboard/services/' + d.id); }

                $scope.moreClick = function(d, e) {
      $location.path('/dashboard/services/' + d.id);
      e.stopPropagation();
    }
  }
]);

(function() {
  'use strict';

  angular.module('kubernetesApp.components.dashboard')
      .directive('d3MinionBarGauge', [
        'd3DashboardService',
        function(d3DashboardService) {

          return {
            restrict: 'E',
            scope: {
              data: '=',
              thickness: '@',
              graphWidth: '@',
              graphHeight: '@'

            },
            link: function(scope, element, attrs) {

              var draw = function(d3) {
                var svg = d3.select("svg.chart");
                var legendSvg = d3.select("svg.legend");
                window.onresize = function() { return scope.$apply(); };

                scope.$watch(function() { return angular.element(window)[0].innerWidth; },
                             function() { return scope.render(scope.data); });

                scope.$watch('data', function(newVals, oldVals) {
                  return initOrUpdate(newVals, oldVals);

                }, true);

                function initOrUpdate(newVals, oldVals) {
                  if (oldVals === null || oldVals === undefined) {
                    return scope.render(newVals);
                  } else {
                    return update(oldVals, newVals);
                  }
                }

                var textOffset = 10;
                var el = null;
                var radius = 100;
                var oldData = [];

                function init(options) {
                  var clone = options.data;
                  var preparedData = setData(clone);
                  setup(preparedData, options.width, options.height);
                }

                function setup(data, w, h) {
                  svg = d3.select(element[0]).append("svg").attr("width", "100%");

                  legendSvg = d3.select(element[0]).append("svg").attr("width", "100%");

                  var chart = svg.attr("class", "chart")
                                  .attr("width", w)
                                  .attr("height", h - 25)
                                  .append("svg:g")
                                  .attr("class", "concentricchart")
                                  .attr("transform", "translate(" + ((w / 2)) + "," + h / 4 + ")");

                  var legend = legendSvg.attr("class", "legend").attr("width", w);

                  radius = Math.min(w, h) / 2;

                  var hostName = legendSvg.append("text")
                                     .attr("class", "hostName")
                                     .attr("transform", "translate(" + ((w - 120) / 2) + "," + 15 + ")");

                  var label_legend_area = legendSvg.append("svg:g")
                                              .attr("class", "label_legend_area")
                                              .attr("transform", "translate(" + ((w - 185) / 2) + "," + 35 + ")");

                  var legend_group = label_legend_area.append("svg:g").attr("class", "legend_group");

                  var label_group = label_legend_area.append("svg:g")
                                        .attr("class", "label_group")
                                        .attr("transform", "translate(" + 25 + "," + 11 + ")");

                  var stats_group = label_legend_area.append("svg:g")
                                        .attr("class", "stats_group")
                                        .attr("transform", "translate(" + 85 + "," + 11 + ")");

                  var path_group = chart.append("svg:g")
                                       .attr("class", "path_group")
                                       .attr("transform", "translate(0," + (h / 4) + ")");
                  var value_group = chart.append("svg:g")
                                        .attr("class", "value_group")
                                        .attr("transform", "translate(" + -(w * 0.205) + "," + -(h * 0.10) + ")");
                  generateArcs(chart, data);
                }

                function update(_oldData, _newData) {
                  if (_newData === undefined || _newData === null) {
                    return;
                  }

                  var clone = jQuery.extend(true, {}, _newData);
                  var cloneOld = jQuery.extend(true, {}, _oldData);
                  var preparedData = setData(clone);
                  oldData = setData(cloneOld);
                  animate(preparedData);
                }

                function animate(data) { generateArcs(null, data); }

                function setData(data) {
                  var diameter = 2 * Math.PI * radius;
                  var localData = [];

                  $.each(data[0].segments, function(ri, value) {

                    function calcAngles(v) {
                      var segmentValueSum = 200;
                      if (v > segmentValueSum) {
                        v = segmentValueSum;
                      }

                      var segmentValue = v;
                      var fraction = segmentValue / segmentValueSum;
                      var arcBatchLength = fraction * 4 * Math.PI;
                      var arcPartition = arcBatchLength;
                      var startAngle = Math.PI * 2;
                      var endAngle = startAngle + arcPartition;

                      return {
                        startAngle: startAngle,
                        endAngle: endAngle
                      };
                    }

                    var valueData = calcAngles(value.value);
                    data[0].segments[ri].startAngle = valueData.startAngle;
                    data[0].segments[ri].endAngle = valueData.endAngle;

                    var maxData = value.maxData;
                    var maxTickData = calcAngles(maxData.maxValue + 0.2);
                    data[0].segments[ri].maxTickStartAngle = maxTickData.startAngle;
                    data[0].segments[ri].maxTickEndAngle = maxTickData.endAngle;

                    var maxArcData = calcAngles(maxData.maxValue);
                    data[0].segments[ri].maxArcStartAngle = maxArcData.startAngle;
                    data[0].segments[ri].maxArcEndAngle = maxArcData.endAngle;

                    data[0].segments[ri].index = ri;
                  });
                  localData.push(data[0].segments);
                  return localData[0];
                }

                function generateArcs(_svg, data) {
                  var chart = svg;
                  var transitionTime = 750;
                  $.each(data, function(index, value) {
                    if (oldData[index] !== undefined) {
                      data[index].previousEndAngle = oldData[index].endAngle;
                    } else {
                      data[index].previousEndAngle = 0;
                    }
                  });
                  var thickness = parseInt(scope.thickness, 10);
                  var ir = (parseInt(scope.graphWidth, 10) / 3);
                  var path_group = svg.select('.path_group');
                  var arc_group = path_group.selectAll(".arc_group").data(data);
                  var arcEnter = arc_group.enter().append("g").attr("class", "arc_group");

                  arcEnter.append("path").attr("class", "bg-circle").attr("d", getBackgroundArc(thickness, ir));

                  arcEnter.append("path")
                      .attr("class", function(d, i) { return 'max_tick_arc ' + d.maxData.maxTickClassNames; });

                  arcEnter.append("path")
                      .attr("class", function(d, i) { return 'max_bg_arc ' + d.maxData.maxClassNames; });

                  arcEnter.append("path").attr("class", function(d, i) { return 'value_arc ' + d.classNames; });

                  var max_tick_arc = arc_group.select(".max_tick_arc");

                  max_tick_arc.transition()
                      .attr("class", function(d, i) { return 'max_tick_arc ' + d.maxData.maxTickClassNames; })
                      .attr("d", function(d) {
                        var arc = maxArc(thickness, ir);
                        arc.startAngle(d.maxTickStartAngle);
                        arc.endAngle(d.maxTickEndAngle);
                        return arc(d);
                      });

                  var max_bg_arc = arc_group.select(".max_bg_arc");

                  max_bg_arc.transition()
                      .attr("class", function(d, i) { return 'max_bg_arc ' + d.maxData.maxClassNames; })
                      .attr("d", function(d) {
                        var arc = maxArc(thickness, ir);
                        arc.startAngle(d.maxArcStartAngle);
                        arc.endAngle(d.maxArcEndAngle);
                        return arc(d);
                      });

                  var value_arc = arc_group.select(".value_arc");

                  value_arc.transition().ease("exp").attr("class", function(d, i) {
                    return 'value_arc ' + d.classNames;
                  }).duration(transitionTime).attrTween("d", function(d) { return arcTween(d, thickness, ir); });

                  arc_group.exit()
                      .select(".value_arc")
                      .transition()
                      .ease("exp")
                      .duration(transitionTime)
                      .attrTween("d", function(d) { return arcTween(d, thickness, ir); })
                      .remove();

                  drawLabels(chart, data, ir, thickness);
                  buildLegend(chart, data);
                }

                function arcTween(b, thickness, ir) {
                  var prev = JSON.parse(JSON.stringify(b));
                  prev.endAngle = b.previousEndAngle;
                  var i = d3.interpolate(prev, b);
                  return function(t) { return getArc(thickness, ir)(i(t)); };
                }

                function maxArc(thickness, ir) {
                  var arc = d3.svg.arc().innerRadius(function(d) {
                    return getRadiusRing(ir, d.index);
                  }).outerRadius(function(d) { return getRadiusRing(ir + thickness, d.index); });
                  return arc;
                }

                function drawLabels(chart, data, ir, thickness) {
                  svg.select('.value_group').selectAll("*").remove();
                  var counts = data.length;
                  var value_group = chart.select('.value_group');
                  var valueLabels = value_group.selectAll("text.value").data(data);
                  valueLabels.enter()
                      .append("svg:text")
                      .attr("class", "value")
                      .attr(
                           "transform", function(d) { return "translate(" + (getRadiusRing(ir, counts - 1)) + ", 0)"; })
                      .attr("dx", function(d, i) { return 0; })
                      .attr("dy", function(d, i) { return (thickness + 3) * i; })
                      .attr("text-anchor", function(d) { return "start"; })
                      .text(function(d) { return d.value; });
                  valueLabels.transition().duration(300).attrTween(
                      "d", function(d) { return arcTween(d, thickness, ir); });
                  valueLabels.exit().remove();
                }

                function buildLegend(chart, data) {
                  var svg = legendSvg;
                  svg.select('.label_group').selectAll("*").remove();
                  svg.select('.legend_group').selectAll("*").remove();
                  svg.select('.stats_group').selectAll("*").remove();

                  var host_name = svg.select('.hostName');
                  var label_group = svg.select('.label_group');
                  var stats_group = svg.select('.stats_group');

                  host_name.text(data[0].hostName);

                  host_name = svg.selectAll("text.hostName").data(data);

                  host_name.attr("text-anchor", function(d) { return "start"; })
                      .text(function(d) { return d.hostName; });
                  host_name.exit().remove();

                  var labels = label_group.selectAll("text.labels").data(data);
                  labels.enter()
                      .append("svg:text")
                      .attr("class", "labels")
                      .attr("dy", function(d, i) { return 19 * i; })
                      .attr("text-anchor", function(d) { return "start"; })
                      .text(function(d) { return d.label; });
                  labels.exit().remove();

                  var stats = stats_group.selectAll("text.stats").data(data);
                  stats.enter()
                      .append("svg:text")
                      .attr("class", "stats")
                      .attr("dy", function(d, i) { return 19 * i; })
                      .attr("text-anchor", function(d) { return "start"; })
                      .text(function(d) { return d.stats; });
                  stats.exit().remove();

                  var legend_group = svg.select('.legend_group');
                  var legend = legend_group.selectAll("rect").data(data);
                  legend.enter()
                      .append("svg:rect")
                      .attr("x", 2)
                      .attr("y", function(d, i) { return 19 * i; })
                      .attr("width", 13)
                      .attr("height", 13)
                      .attr("class", function(d, i) { return "rect " + d.classNames; });

                  legend.exit().remove();
                }

                function getRadiusRing(ir, i) { return ir - (i * 20); }

                function getArc(thickness, ir) {
                  var arc = d3.svg.arc()
                                .innerRadius(function(d) { return getRadiusRing(ir, d.index); })
                                .outerRadius(function(d) { return getRadiusRing(ir + thickness, d.index); })
                                .startAngle(function(d, i) { return d.startAngle; })
                                .endAngle(function(d, i) { return d.endAngle; });
                  return arc;
                }

                function getBackgroundArc(thickness, ir) {
                  var arc = d3.svg.arc()
                                .innerRadius(function(d) { return getRadiusRing(ir, d.index); })
                                .outerRadius(function(d) { return getRadiusRing(ir + thickness, d.index); })
                                .startAngle(0)
                                .endAngle(function() { return 2 * Math.PI; });
                  return arc;
                }

                scope.render = function(data) {
                  if (data === undefined || data === null) {
                    return;
                  }

                  svg.selectAll("*").remove();

                  var graph = $(element[0]);
                  var w = scope.graphWidth;
                  var h = scope.graphHeight;

                  var options = {
                    data: data,
                    width: w,
                    height: h
                  };

                  init(options);
                };
              };
              d3DashboardService.d3().then(draw);
            }
          };
        }
      ]);
}());

(function() {
  'use strict';

  angular.module('kubernetesApp.components.dashboard')
      .directive(
           'dashboardHeader',
           function() {
             'use strict';
             return {
               restrict: 'A',
               replace: true,
               scope: {user: '='},
               templateUrl: "/components/dashboard/pages/header.html",
               controller: [
                 '$scope',
                 '$filter',
                 '$location',
                 '$rootScope',
                 function($scope, $filter, $location, $rootScope) {
                   $scope.$watch('page', function(newValue, oldValue) {
                     if (typeof newValue !== 'undefined') {
                       $location.path(newValue);
                     }
                   });

                   $scope.subpages = [
                     {
                       category: 'dashboard',
                       name: 'Groups',
                       value: '/dashboard/groups/type/selector/',
                       id: 'groupsView'
                     },
                     {category: 'dashboard', name: 'Pods', value: '/dashboard/pods', id: 'podsView'},
                     {category: 'dashboard', name: 'Minions', value: '/dashboard/minions', id: 'minionsView'},
                     {
                       category: 'dashboard',
                       name: 'Replication Controllers',
                       value: '/dashboard/replicationcontrollers',
                       id: 'rcView'
                     },
                     {category: 'dashboard', name: 'Services', value: '/dashboard/services', id: 'servicesView'},
                     {category: 'dashboard', name: 'Events', value: '/dashboard/events', id: 'eventsView'},
                   ];
                 }
               ]
             };
           })
      .directive('dashboardFooter',
                 function() {
                   'use strict';
                   return {
                     restrict: 'A',
                     replace: true,
                     templateUrl: "/components/dashboard/pages/footer.html",
                     controller: ['$scope', '$filter', function($scope, $filter) {}]
                   };
                 })
      .directive('mdTable', function() {
        'use strict';
        return {
          restrict: 'E',
          scope: {
            headers: '=',
            content: '=',
            sortable: '=',
            filters: '=',
            customClass: '=customClass',
            thumbs: '=',
            count: '='
          },
          controller: ["$scope", "$filter", "$window", "$location", function($scope, $filter, $window, $location) {
            var orderBy = $filter('orderBy');
            $scope.currentPage = 0;
            $scope.nbOfPages = function() { return Math.ceil($scope.content.length / $scope.count); };
            $scope.handleSort = function(field) {
              if ($scope.sortable.indexOf(field) > -1) {
                return true;
              } else {
                return false;
              }
            };
            $scope.go = function(d) {
              if (d.pod) {
                $location.path('/dashboard/pods/' + d.pod);
              } else if (d.name) {
                $location.path('/dashboard/services/' + d.name);
              }
            };
            $scope.order = function(predicate, reverse) {
              $scope.content = orderBy($scope.content, predicate, reverse);
              $scope.predicate = predicate;
            };
            $scope.order($scope.sortable[0], false);
            $scope.getNumber = function(num) { return new Array(num); };
            $scope.goToPage = function(page) { $scope.currentPage = page; };
          }],
          templateUrl: '/views/partials/md-table.tmpl.html'
        };
      });

}());

angular.module('kubernetesApp.components.dashboard')
    .factory('d3DashboardService', [
      '$document',
      '$q',
      '$rootScope',
      function($document, $q, $rootScope) {
        var d = $q.defer();
        function onScriptLoad() {
          // Load client in the browser
          $rootScope.$apply(function() { d.resolve(window.d3); });
        }
        // Create a script tag with d3 as the source
        // and call our onScriptLoad callback when it
        // has been loaded
        var scriptTag = $document[0].createElement('script');
        scriptTag.type = 'text/javascript';
        scriptTag.async = true;
        scriptTag.src = '/vendor/d3/d3.min.js';
        scriptTag.onreadystatechange = function() {
          if (this.readyState == 'complete') onScriptLoad();
        };
        scriptTag.onload = onScriptLoad;

        var s = $document[0].getElementsByTagName('body')[0];
        s.appendChild(scriptTag);

        return {
          d3: function() { return d.promise; }
        };
      }
    ]);

(function() {
  'use strict';

  angular.module('pods', []).service('podService', PodDataService);

  /**
   * Pod DataService
   * Mock async data service.
   *
   * @returns {{loadAll: Function}}
   * @constructor
   */
  function PodDataService($q) {
    var pods = {
      "kind": "PodList",
      "creationTimestamp": null,
      "selfLink": "/api/v1beta1/pods",
      "resourceVersion": 166552,
      "apiVersion": "v1beta1",
      "items": [{
        "id": "hello",
        "uid": "0fe3644e-ab53-11e4-8ae8-061695c59fcf",
        "creationTimestamp": "2015-02-03T03:16:36Z",
        "selfLink": "/api/v1beta1/pods/hello?namespace=default",
        "resourceVersion": 466,
        "namespace": "default",
        "labels": {"environment": "testing", "name": "hello"},
        "desiredState": {
          "manifest": {
            "version": "v1beta2",
            "id": "",
            "volumes": null,
            "containers": [{
              "name": "hello",
              "image": "quay.io/kelseyhightower/hello",
              "ports": [{"hostPort": 80, "containerPort": 80, "protocol": "TCP"}],
              "imagePullPolicy": "PullIfNotPresent"
            }],
            "restartPolicy": {"always": {}},
            "dnsPolicy": "ClusterFirst"
          }
        },
        "currentState": {
          "manifest": {"version": "", "id": "", "volumes": null, "containers": null, "restartPolicy": {}},
          "status": "Running",
          "host": "172.31.12.204",
          "podIP": "10.244.73.2",
          "info": {
            "hello": {
              "state": {"running": {"startedAt": "2015-02-03T03:16:51Z"}},
              "restartCount": 0,
              "image": "quay.io/kelseyhightower/hello",
              "containerID": "docker://96ade8ff30a44c4489969eaf343a7899317671b07a9766ecd0963e9b41501256"
            },
            "net": {
              "state": {"running": {"startedAt": "2015-02-03T03:16:41Z"}},
              "restartCount": 0,
              "podIP": "10.244.73.2",
              "image": "kubernetes/pause:latest",
              "containerID": "docker://93d32603cafbff7165dadb1d4527899c24246bca2f5e6770b8297fd3721b272c"
            }
          }
        }
      }]
    };

    // Uses promises
    return {
      loadAll: function() {
        // Simulate async call
        return $q.when(pods);
      }
    };
  }
  PodDataService.$inject = ["$q"];

})();

(function() {
  'use strict';

  angular.module('replicationControllers', [])
      .service('replicationControllerService', ReplicationControllerDataService);

  /**
   * Replication Controller DataService
   * Mock async data service.
   *
   * @returns {{loadAll: Function}}
   * @constructor
   */
  function ReplicationControllerDataService($q) {
    var replicationControllers = {
      "kind": "ReplicationControllerList",
      "creationTimestamp": null,
      "selfLink": "/api/v1beta1/replicationControllers",
      "resourceVersion": 166552,
      "apiVersion": "v1beta1",
      "items": []
    };

    // Uses promises
    return {
      loadAll: function() {
        // Simulate async call
        return $q.when(replicationControllers);
      }
    };
  }
  ReplicationControllerDataService.$inject = ["$q"];

})();

(function() {
  'use strict';

  angular.module('services', []).service('serviceService', ServiceDataService);

  /**
   * Service DataService
   * Mock async data service.
   *
   * @returns {{loadAll: Function}}
   * @constructor
   */
  function ServiceDataService($q) {
    var services = {
      "kind": "ServiceList",
      "creationTimestamp": null,
      "selfLink": "/api/v1beta1/services",
      "resourceVersion": 166552,
      "apiVersion": "v1beta1",
      "items": [
        {
          "id": "kubernetes",
          "uid": "626dd08d-ab51-11e4-8ae8-061695c59fcf",
          "creationTimestamp": "2015-02-03T03:04:36Z",
          "selfLink": "/api/v1beta1/services/kubernetes?namespace=default",
          "resourceVersion": 11,
          "namespace": "default",
          "port": 443,
          "protocol": "TCP",
          "labels": {"component": "apiserver", "provider": "kubernetes"},
          "selector": null,
          "containerPort": 0,
          "portalIP": "10.244.66.215",
          "sessionAffinity": "None"
        },
        {
          "id": "kubernetes-ro",
          "uid": "626f9584-ab51-11e4-8ae8-061695c59fcf",
          "creationTimestamp": "2015-02-03T03:04:36Z",
          "selfLink": "/api/v1beta1/services/kubernetes-ro?namespace=default",
          "resourceVersion": 12,
          "namespace": "default",
          "port": 80,
          "protocol": "TCP",
          "labels": {"component": "apiserver", "provider": "kubernetes"},
          "selector": null,
          "containerPort": 0,
          "portalIP": "10.244.182.142",
          "sessionAffinity": "None"
        }
      ]
    };

    // Uses promises
    return {
      loadAll: function() {
        // Simulate async call
        return $q.when(services);
      }
    };
  }
  ServiceDataService.$inject = ["$q"];

})();

/**
 Copyright 2015 Google Inc. All rights reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**=========================================================
* Module: Graph
* Visualizer for force directed graph
=========================================================*/
(function() {
  "use strict";
  angular.module("kubernetesApp.components.graph", [
    "kubernetesApp.services",
    "kubernetesApp.components.graph.services",
    "kubernetesApp.components.graph.services.d3",
    "kubernetesApp.components.graph.services.d3.rendering",
    "yaru22.jsonHuman"
  ])
      .controller("GraphCtrl", [
        "$scope",
        "lodash",
        "viewModelService",
        "pollK8sDataService",
        "$location",
        "$window",
        "inspectNodeService",
        function($scope, _, viewModelService, pollK8sDataService, $location, $window, inspectNodeService) {
          $scope.showHide = function(id) {
            var element = document.getElementById(id);
            if (element) {
              element.style.display = (element.style.display === "none") ? "block" : "none";
            }
          };

          $scope.showElement = function(id) {
            var element = document.getElementById(id);
            if (element) {
              element.style.display = "block";
            }
          };

          $scope.hideElement = function(id) {
            var element = document.getElementById(id);
            if (element) {
              element.style.display = "none";
            }
          };

          $scope.pollK8sDataService = pollK8sDataService;

          $scope.getPlayIcon = function() {
            return pollK8sDataService.isPolling() ? "components/graph/img/Pause.svg" : "components/graph/img/Play.svg";
          };

          $scope.togglePlay = function() {
            if (pollK8sDataService.isPolling()) {
              pollK8sDataService.stop($scope);
            } else {
              pollK8sDataService.start($scope);
            }
          };

          // Update the view when the polling starts or stops.
          $scope.$watch("pollK8sDataService.isPolling()", function(newValue, oldValue) {
            if (newValue !== oldValue) {
              $scope.$apply();
            }
          });

          $scope.getSourceIcon = function() {
            return pollK8sDataService.k8sdatamodel.useSampleData ? "components/graph/img/SampleData.svg" :
                                                                   "components/graph/img/LiveData.svg";
          };

          $scope.toggleSource = function() {
            pollK8sDataService.k8sdatamodel.useSampleData = !pollK8sDataService.k8sdatamodel.useSampleData;
            pollK8sDataService.refresh($scope);
          };

          $scope.refresh = function() { pollK8sDataService.refresh($scope); };

          $scope.viewModelService = viewModelService;
          $scope.getTransformNames = function() { return _.sortBy(viewModelService.viewModel.transformNames); };

          $scope.selectedTransformName = viewModelService.defaultTransformName;

          // Sets the selected transform name
          $scope.setSelectedTransformName = function(transformName) {
            pollK8sDataService.stop($scope);
            $scope.selectedTransformName = transformName;
            $scope.updateModel();
          };

          $scope.updateModel = function() {
            viewModelService.generateViewModel(pollK8sDataService.k8sdatamodel.data, $scope.selectedTransformName);
          };

          // Update the view model when the data model changes.
          $scope.$watch("pollK8sDataService.k8sdatamodel.sequenceNumber", function(newValue, oldValue) {
            if (newValue !== oldValue) {
              $scope.updateModel();
            }
          });

          pollK8sDataService.refresh($scope);

          $scope.getLegendNodeTypes = function() {
            var result = [];
            var legend = viewModelService.getLegend();
            if (legend && legend.nodes) {
              result = _.keys(legend.nodes).filter(function(type) { return legend.nodes[type].available; }).sort();
            }

            return result;
          };

          $scope.getLegendNodeDisplayName = function(type) {
            var result = type;
            var legend = viewModelService.getLegend();
            if (legend && legend.nodes && legend.nodes[type] && legend.nodes[type].displayName) {
              result = legend.nodes[type].displayName;
            }

            return result;
          };

          $scope.getLegendNodeFill = function(type) {
            var result = "white";
            var legend = viewModelService.getLegend();
            if (legend && legend.nodes && legend.nodes[type]) {
              if (legend.nodes[type].selected) {
                result = legend.nodes[type].style.fill;
              }
            }

            return result;
          };

          $scope.getLegendLinkTypes = function() {
            var result = [];
            var legend = viewModelService.getLegend();
            if (legend && legend.links) {
              result = _.keys(legend.links).filter(function(type) { return legend.links[type].available; }).sort();
            }

            return result;
          };

          $scope.getLegendLinkStyle = function(type) {
            var result = {};
            var legend = viewModelService.getLegend();
            if (legend && legend.links) {
              result = legend.links[type].style;
            }

            return result;
          };

          $scope.getLegendLinkStyleStrokeWidth = function(type, defaultWidth) {
            var style = $scope.getLegendLinkStyle(type);
            return $window.Math.max(style.width, defaultWidth);
          };

          $scope.toggleLegend = function(type) {
            if (type) {
              var legend = viewModelService.getLegend();
              if (legend.nodes) {
                legend.nodes[type].selected = !legend.nodes[type].selected;
                $scope.updateModel();
              }
            }
          };

          var getSelection = function() {
            var selectedNode = undefined;
            var selectionIdList = viewModelService.getSelectionIdList();
            if (selectionIdList && selectionIdList.length > 0) {
              var selectedId = selectionIdList[0];
              selectedNode =
                  _.find(viewModelService.viewModel.data.nodes, function(node) { return node.id === selectedId; });
            }

            return selectedNode;
          };

          var stringifyNoQuotes = function(result) {
            if (typeof result !== "string") {
              if (result !== "undefined") {
                result = JSON.stringify(result);
            result = result.replace(/\"([^(\")"]+)\":/g, "$1:");
              } else {
                result = "undefined";
              }
            }

            return result;
          };

          $scope.getSelectionDetails = function() {
            var results = {};
            var selectedNode = getSelection();
            if (selectedNode && selectedNode.tags) {
              _.forOwn(selectedNode.tags, function(value, property) {
                if (value) {
                  var result = stringifyNoQuotes(value);
                  if (result.length > 0) {
                    results[property] = result;
                  }
                }
              });
            }

            return results;
          };

          $scope.inspectSelection = function() {
            var selectedNode = getSelection();
            if (selectedNode && selectedNode.metadata) {
              inspectNodeService.setDetailData(selectedNode);
              $location.path('/graph/inspect');
            }
          };

          $scope.$watch("viewModelService.getSelectionIdList()", function(newValue, oldValue) {
            if (newValue !== oldValue) {
              var selectionIdList = viewModelService.getSelectionIdList();
              if (!selectionIdList || selectionIdList.length < 1) {
                $scope.hideElement("details");
              } else {
                $scope.showElement("details");
              }
            }
          });

          $scope.getExpandIcon = function() {
            return viewModelService.getSettings().clustered ? "components/graph/img/Collapse.svg" :
                                                              "components/graph/img/Expand.svg";
          };

          $scope.toggleExpand = function() {
            var settings = viewModelService.getSettings();
            settings.clustered = !settings.clustered;
            $scope.updateModel();
          };

          $scope.getSelectIcon = function() {
            return viewModelService.getSelectionHops() ? "components/graph/img/SelectMany.svg" :
                                                         "components/graph/img/SelectOne.svg";
          };

          $scope.toggleSelect = function() {
            var selectionHops = viewModelService.getSelectionHops();
            if (!selectionHops) {
              viewModelService.setSelectionHops(1);
            } else {
              viewModelService.setSelectionHops(0);
            }
          };
        }
      ]);
}());

/**
 Copyright 2015 Google Inc. All rights reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**=========================================================
* Module: Graph
* Visualizer for force directed graph
=========================================================*/
(function() {
  'use strict';

  angular.module('kubernetesApp.components.graph')
      .controller('InspectNodeCtrl', [
        '$scope',
        'inspectNodeService',
        '$location',
        function($scope, inspectNodeService, $location) {
          var nodeDetail = inspectNodeService.getDetailData();
          $scope.element = nodeDetail.id;
          $scope.metadata = nodeDetail.metadata;

          $scope.backToGraph = function() {
            $location.path('/graph');
            $scope.$apply();
          };
        }
      ]);

})();

/**
 Copyright 2015 Google Inc. All rights reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**=========================================================
 * Module: Graph
 * Visualizer for force directed graph.
 * This is a directive that uses d3 to generate an svg
 * element.
 =========================================================*/

angular.module('kubernetesApp.components.graph')
    .directive('d3Visualization', [
      'd3Service',
      'd3RenderingService',
      function(d3Service, d3RenderingService) {
        return {
          restrict: 'E',
          link: function(scope, element, attrs) {
            scope.$watch('viewModelService.viewModel.version', function(newValue, oldValue) {
              if (!window.d3) {
                d3Service.d3().then(d3Rendering);
              } else {
                d3Rendering();
              }
            });

            scope.$watch('selectionIdList', function(newValue, oldValue) {
              if (newValue !== undefined) {
                // The d3Rendering.nodeSelection() method expects a set of objects, each with an id property.
                var nodes = new Set();

                newValue.forEach(function(e) { nodes.add({id: e}); });

                d3Rendering.nodeSelection(nodes);
              }
            });

            var d3Rendering = d3RenderingService.rendering().controllerScope(scope).directiveElement(element[0]);
          }
        };
      }
    ]);

/**
 Copyright 2015 Google Inc. All rights reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

angular.module('kubernetesApp.components.graph')
    .factory('d3Service', [
      '$document',
      '$q',
      '$rootScope',
      function($document, $q, $rootScope) {
        var d = $q.defer();
        function onScriptLoad() {
          // Load client in the browser
          $rootScope.$apply(function() { d.resolve(window.d3); });
        }
        // Create a script tag with d3 as the source
        // and call our onScriptLoad callback when it
        // has been loaded
        var scriptTag = $document[0].createElement('script');
        scriptTag.type = 'text/javascript';
        scriptTag.async = true;
        scriptTag.src = '/vendor/d3/d3.min.js';
        scriptTag.onreadystatechange = function() {
          if (this.readyState == 'complete') onScriptLoad();
        };
        scriptTag.onload = onScriptLoad;

        var s = $document[0].getElementsByTagName('body')[0];
        s.appendChild(scriptTag);

        return {
          d3: function() { return d.promise; }
        };
      }
    ]);

/**
 Copyright 2015 Google Inc. All rights reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**=========================================================
 * Module: Graph
 * Visualizer for force directed graph.
 * This is a service that provides rendering capabilities
 * for use by the d3 visualization directive.
 =========================================================*/

(function() {
  'use strict';

  var d3RenderingService = function(lodash, d3UtilitiesService, $location, $rootScope, inspectNodeService) {

    function rendering() {
      var CONSTANTS = {
        FIXED_DRAGGING_BIT: 2,
        FIXED_MOUSEOVER_BIT: 4,
        FIXED_PINNED_BIT: 8,
        SHOWPIN_MOUSEOVER_BIT: 2,
        SHOWPIN_METAKEYDOWN_BIT: 4,
        OPACITY_MOUSEOVER: 0.7,
        OPACITY_DESELECTED: 0.2,
        // TODO(duftler): Externalize these defaults.
        DEFAULTS: {
          SVG_INITIAL_HEIGHT: 700,
          FORCE_CLUSTERED_GRAVITY: 0.02,
          FORCE_CLUSTERED_CHARGE: 0,
          FORCE_CLUSTERED_REFRESH_STARTING_ALPHA: 0.02,
          FORCE_NONCLUSTERED_GRAVITY: 0.40,
          FORCE_NONCLUSTERED_CHARGE: -1250,
          FORCE_NONCLUSTERED_REFRESH_STARTING_ALPHA: 0.01,
          FORCE_REFRESH_THRESHOLD_PERCENTAGE: 0.25,
          CLUSTER_INNER_PADDING: 4,
          CLUSTER_OUTER_PADDING: 32
        }
      };

      var directiveElement;
      var controllerScope;

      // Used to maintain settings that must survive refresh.
      var viewSettingsCache = {};
      var nodeSettingsCache = {};

      // Contains the currently-seleted resources.
      var selection = {nodes: new Set(), edges: new Set(), edgelabels: new Set()};

      var node;
      var circle;
      var image;
      var link;
      var edgepaths;
      var edgelabels;
      var force;
      var zoom;
      var g;
      var center;

      // Used to store the largest node for each cluster.
      var builtClusters;
      // The configured padding between nodes within a cluster.
      var clusterInnerPadding;
      // The configured padding between clusters.
      var clusterOuterPadding;

      // Select all edges and edgelabels where both the source and target nodes are selected.
      function selectEdgesInScope() {
        selection.edges.clear();
        selection.edgelabels.clear();

        // Add each edge where both the source and target nodes are selected.
        if (link) {
          link.each(function(e) {
            if (d3UtilitiesService.setHas(selection.nodes, e.source) &&
                d3UtilitiesService.setHas(selection.nodes, e.target)) {
              selection.edges.add(e);
            }
          });
        }

        // Add each edge label where both the source and target nodes are selected.
        if (edgelabels) {
          edgelabels.each(function(e) {
            if (d3UtilitiesService.setHas(selection.nodes, e.source) &&
                d3UtilitiesService.setHas(selection.nodes, e.target)) {
              selection.edgelabels.add(e);
            }
          });
        }
      }

      // Adjust the opacity of all resources to indicate selected items.
      function applySelectionToOpacity() {
        var notSelectedOpacity = CONSTANTS.OPACITY_DESELECTED;

        // If nothing is selected, show everything.
        if (!selection.nodes.size && !selection.edges.size && !selection.edgelabels.size) {
          notSelectedOpacity = 1;
        }

        // Reduce the opacity of all but the selected nodes.
        node.style('opacity', function(e) {
          var newOpacity = d3UtilitiesService.setHas(selection.nodes, e) ? 1 : notSelectedOpacity;

          if (e.origOpacity) {
            e.origOpacity = newOpacity;
          }

          return newOpacity;
        });

        // Reduce the opacity of all but the selected edges.
        if (link) {
          link.style('opacity', function(e) {
            return d3UtilitiesService.setHas(selection.edges, e) ? 1 : notSelectedOpacity;
          });
        }

        // Reduce the opacity of all but the selected edge labels.
        if (edgelabels) {
          edgelabels.style('opacity', function(e) {
            return d3UtilitiesService.setHas(selection.edgelabels, e) ? 1 : notSelectedOpacity;
          });
        }

        var selectionIdList = [];

        selection.nodes.forEach(function(e) {
          if (e.id !== undefined) {
            selectionIdList.push(e.id);
          }
        });

        controllerScope.viewModelService.setSelectionIdList(selectionIdList);

        _.defer(function() {
          $rootScope.$apply();
          autosizeSVG(d3, false);
        });
      }

      // Return the dimensions of the parent element of the d3 visualization directive.
      function getParentContainerDimensions(d3) {
        var parentNode = d3.select(directiveElement.parentNode);
        var width = parseInt(parentNode.style('width'));
        var height = parseInt(parentNode.style('height'));

        return [width, height];
      }

      // Resize the svg element.
      function resizeSVG(d3, newSVGDimensions) {
        var svg = d3.select(directiveElement).select('svg');
        var width = newSVGDimensions[0];
        var height = newSVGDimensions[1];

        svg.attr('width', width);
        svg.attr('height', height);

        // We want the width and height to survive redraws.
        viewSettingsCache.width = width;
        viewSettingsCache.height = height;

        force.size([width, height]);
      }

      // Adjust the size of the svg element to a new size derived from the dimensions of the parent.
      function autosizeSVG(d3, windowWasResized) {
        var containerDimensions = getParentContainerDimensions(d3);
        var width = containerDimensions[0] - 16;
        var height = containerDimensions[1] - 19;

        resizeSVG(d3, [width, height]);

        if (windowWasResized) {
          force.resume();
        }
      }

      // Render the graph.
      function graph() {
        // We want to stop any prior simulation before starting a new one.
        if (force) {
          force.stop();
        }

        var d3 = window.d3;
        d3.select(window).on('resize', windowWasResized);

        // TODO(duftler): Derive the initial svg height from the container rather than the other way around.
        var width = viewSettingsCache.width ? viewSettingsCache.width : getParentContainerDimensions(d3)[0] - 16;
        var height = viewSettingsCache.height ? viewSettingsCache.height : CONSTANTS.DEFAULTS.SVG_INITIAL_HEIGHT;

        center = [width / 2, height / 2];

        var color = d3.scale.category20();

        d3.select(directiveElement).select('svg').remove();

        var svg = d3.select(directiveElement)
                      .append('svg')
                      .attr('width', width)
                      .attr('height', height)
                      .attr('class', 'graph');

        svg.append('defs')
            .selectAll('marker')
            .data(['suit', 'licensing', 'resolved'])
            .enter()
            .append('marker')
            .attr('id', function(d) { return d; })
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 60)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .attr('markerUnits', 'userSpaceOnUse')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5 L10,0 L0, -5')
            .style('stroke', 'black')
            .style('opacity', '1');

        svg.on('contextmenu', function(data, index) {
          if (d3.select('.d3-context-menu').style('display') !== 'block') {
            d3UtilitiesService.showContextMenu(d3, data, index, canvasContextMenu);
          }

          // Even if we don't show a new context menu, we don't want the browser's default context menu shown.
          d3.event.preventDefault();
        });

        zoom = d3.behavior.zoom().scaleExtent([0.5, 12]).on('zoom', zoomed);

        if (viewSettingsCache.translate && viewSettingsCache.scale) {
          zoom.translate(viewSettingsCache.translate).scale(viewSettingsCache.scale);
        }

        g = svg.append('g');

        svg.call(zoom).on('dblclick.zoom', null).call(zoom.event);

        var origWheelZoomHandler = svg.on('wheel.zoom');
        svg.on('wheel.zoom', wheelScrollHandler);

        var showPin = 0;

        d3.select('body')
            .on('keydown',
                function() {
                  if (d3.event.ctrlKey) {
                    svg.on('wheel.zoom', origWheelZoomHandler);
                    svg.attr('class', 'graph zoom-cursor');
                  } else if (d3.event.metaKey) {
                    showPin |= CONSTANTS.SHOWPIN_METAKEYDOWN_BIT;

                    if (showPin === (CONSTANTS.SHOWPIN_MOUSEOVER_BIT + CONSTANTS.SHOWPIN_METAKEYDOWN_BIT)) {
                      svg.attr('class', 'graph pin-cursor');
                    }
                  }
                })
            .on('keyup', function() {
              if (!d3.event.ctrlKey) {
                svg.on('wheel.zoom', wheelScrollHandler);
                svg.attr('class', 'graph');
              }

              if (!d3.event.metaKey) {
                showPin &= ~CONSTANTS.SHOWPIN_METAKEYDOWN_BIT;
                svg.attr('class', 'graph');
              }
            });

        function windowBlur() {
          // If we Cmd-Tab away from this window, the keyup event won't have a chance to fire.
          // Unsetting this bit here ensures that the Pin cursor won't be displayed when focus returns to this window.
          showPin &= ~CONSTANTS.SHOWPIN_METAKEYDOWN_BIT;
          svg.attr('class', 'graph');
        }

        window.addEventListener('blur', windowBlur);

        var drag = d3.behavior.drag()
                       .origin(function(d) { return d; })
                       .on('dragstart', dragstarted)
                       .on('drag', dragmove)
                       .on('dragend', dragended);

        var graph = undefined;
        if (controllerScope.viewModelService) {
          graph = controllerScope.viewModelService.viewModel.data;
        }

        if (graph === undefined) {
          return;
        }

        force = d3.layout.force().size([width, height]).on('tick', tick);

        if (graph.configuration.settings.clustered) {
          force.gravity(CONSTANTS.DEFAULTS.FORCE_CLUSTERED_GRAVITY).charge(CONSTANTS.DEFAULTS.FORCE_CLUSTERED_CHARGE);

          clusterInnerPadding = getClusterInnerPadding();
          clusterOuterPadding = getClusterOuterPadding();
        } else {
          force.gravity(CONSTANTS.DEFAULTS.FORCE_NONCLUSTERED_GRAVITY)
              .charge(CONSTANTS.DEFAULTS.FORCE_NONCLUSTERED_CHARGE)
              .linkDistance(function(d) { return d.distance; })
              .links(graph.links);

          // Create all the line svgs but without locations yet.
          link = g.selectAll('.link')
                     .data(graph.links)
                     .enter()
                     .append('line')
                     .attr('class', 'link')
                     .style('marker-end',
                            function(d) {
                              if (d.directed) {
                                return 'url(#suit)';
                              }
                              return 'none';
                            })
                     .style('stroke', function(d) { return d.stroke; })
                     .style('stroke-dasharray', function(d) { return d.dash ? (d.dash + ', ' + d.dash) : ('1, 0'); })
                     .style('stroke-width', function(d) { return d.width; });
        }

        var selectedNodeSet = new Set();
        var newPositionCount = 0;

        // Apply all cached settings and count number of nodes with new positions.
        graph.nodes.forEach(function(n) {
          if (applyCachedSettingsToNodes(n, selectedNodeSet)) {
            ++newPositionCount;
          }
        });

        // If any nodes in the graph are explicitly selected, the cached selection is overridden.
        if (selectedNodeSet.size) {
          selection.nodes = selectedNodeSet;
        }

        force.nodes(graph.nodes);

        if (newPositionCount < (CONSTANTS.DEFAULTS.FORCE_REFRESH_THRESHOLD_PERCENTAGE * graph.nodes.length)) {
          var startingAlpha = graph.configuration.settings.clustered ?
                                  CONSTANTS.DEFAULTS.FORCE_CLUSTERED_REFRESH_STARTING_ALPHA :
                                  CONSTANTS.DEFAULTS.FORCE_NONCLUSTERED_REFRESH_STARTING_ALPHA;

          force.start().alpha(startingAlpha);
        } else {
          force.start();
        }

        if (graph.configuration.settings.clustered) {
          builtClusters = d3UtilitiesService.buildClusters(graph.nodes);
        }

        node = g.selectAll('.node')
                   .data(graph.nodes)
                   .enter()
                   .append('g')
                   .attr('class', 'node')
                   .on('mouseover', d3_layout_forceMouseover)
                   .on('mouseout', d3_layout_forceMouseout)
                   .on('mouseup', mouseup)
                   .call(drag);

        function mouseup(d) {
          if (!d3.event.metaKey) {
            if (d.dragMoved === undefined || !d.dragMoved) {
              toggleSelected(d);
            }
          } else {
            togglePinned(d);
          }
        }

        // Create the div element that will hold the context menu.
        d3.selectAll('.d3-context-menu').data([1]).enter().append('div').attr('class', 'd3-context-menu');

        // Close context menu.
        d3.select('body')
            .on('click.d3-context-menu', function() { d3.select('.d3-context-menu').style('display', 'none'); });

        node.each(function(n) {
          var singleNode = d3.select(this);

          if (n.icon) {
            singleNode.append('image')
                .attr('xlink:href', function(d) { return d.icon; })
                .attr('width', function(d) { return d.size[0]; })
                .attr('height', function(d) { return d.size[1]; })
                .on('contextmenu', function(data, index) {
                  d3UtilitiesService.showContextMenu(d3, data, index, nodeContextMenu);
                });
          } else {
            singleNode.append('circle')
                .attr('r', function(d) { return d.radius; })
                .style('stroke', function(d) { return d.stroke; })
                .style('fill', function(d) { return d.fill; })
                .on('contextmenu', function(data, index) {
                  d3UtilitiesService.showContextMenu(d3, data, index, nodeContextMenu);
                });
          }
        });

        var text = node.append('text').attr('dx', 10).attr('dy', '.35em');

        text.text(function(d) { return graph.configuration.settings.showNodeLabels && !d.hideLabel ? d.name : ''; });

        text.each(function(e) {
          var singleText = d3.select(this);
          var parentNode = singleText.node().parentNode;

          d3.select(parentNode)
              .append('image')
              .attr('xlink:href', function(d) { return '/components/graph/img/Pin.svg'; })
              .attr('display', function(d) { return d.fixed & CONSTANTS.FIXED_PINNED_BIT ? '' : 'none'; })
              .attr('width', function(d) { return '13px'; })
              .attr('height', function(d) { return '13px'; });
        });

        if (!graph.configuration.settings.clustered && graph.configuration.settings.showEdgeLabels) {
          edgepaths = g.selectAll('.edgepath')
                          .data(graph.links)
                          .enter()
                          .append('path')
                          .attr({
                            d: function(d) {
                              return 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y;
                            },
                            class: 'edgepath',
                            'fill-opacity': 0,
                            'stroke-opacity': 0,
                            fill: 'blue',
                            stroke: 'red',
                            id: function(d, i) { return 'edgepath' + i }
                          })
                          .style('pointer-events', 'none');

          edgelabels = g.selectAll('.edgelabel')
                           .data(graph.links)
                           .enter()
                           .append('text')
                           .style('pointer-events', 'none')
                           .attr({
                             class: 'edgelabel',
                             id: function(d, i) { return 'edgelabel' + i },
                             dx: function(d) { return d.distance / 3 },
                             dy: 0
                           });

          edgelabels.append('textPath')
              .attr('xlink:href', function(d, i) { return '#edgepath' + i })
              .style('pointer-events', 'none')
              .text(function(d, i) { return d.label });
        }

        circle = g.selectAll('circle');

        if (graph.configuration.settings.clustered && newPositionCount) {
          circle.attr('r', function(d) { return d.radius; })
        }

        image = d3.selectAll('image');

        // If zero nodes are in the current selection, reset the selection.
        var nodeMatches = new Set();

        node.each(function(e) {
          if (d3UtilitiesService.setHas(selection.nodes, e)) {
            nodeMatches.add(e);
          }
        });

        if (!nodeMatches.size) {
          resetSelection();
        } else {
          selection.nodes = nodeMatches;

          selectEdgesInScope();

          applySelectionToOpacity();
        }

        // Create an array logging what is connected to what.
        var linkedByIndex = {};
        for (var i = 0; i < graph.nodes.length; i++) {
          linkedByIndex[i + ',' + i] = 1;
        }

        if (graph.links) {
          graph.links.forEach(function(d) { linkedByIndex[d.source.index + ',' + d.target.index] = 1; });
        }

        // Adjust selection in response to a single-click on a node.
        function toggleSelected(d) {
          // Operation is to select nodes if either no nodes are currently selected or this node is not selected.
          var selectOperation = !selection.nodes.size || !d3UtilitiesService.setHas(selection.nodes, d);

          if (selectOperation) {
            // Add the clicked node.
            selection.nodes.add(d);

            // Add each node within 1 hop from the clicked node.
            node.each(function(e) {
              if (d3UtilitiesService.neighboring(d, e, linkedByIndex,
                                                 controllerScope.viewModelService.getSelectionHops()) |
                  d3UtilitiesService.neighboring(e, d, linkedByIndex,
                                                 controllerScope.viewModelService.getSelectionHops())) {
                selection.nodes.add(e);
              }
            });
          } else {
            // De-select the clicked node.
            selection.nodes.delete(d);

            // Remove each node within 1 hop from the clicked node.
            node.each(function(e) {
              if (d3UtilitiesService.neighboring(d, e, linkedByIndex,
                                                 controllerScope.viewModelService.getSelectionHops()) |
                  d3UtilitiesService.neighboring(e, d, linkedByIndex,
                                                 controllerScope.viewModelService.getSelectionHops())) {
                selection.nodes.delete(e);
              }
            });
          }

          selectEdgesInScope();

          applySelectionToOpacity();
        }

        // Clear all selected resources.
        function resetSelection() {
          // Show everything.
          selection.nodes.clear();
          selection.edges.clear();
          selection.edgelabels.clear();

          applySelectionToOpacity();
        }

        // Return the configured padding between nodes within a cluster.
        function getClusterInnerPadding() {
          var result = CONSTANTS.DEFAULTS.CLUSTER_INNER_PADDING;

          if (graph.configuration.settings.clusterSettings &&
              graph.configuration.settings.clusterSettings.innerPadding !== undefined) {
            result = graph.configuration.settings.clusterSettings.innerPadding;
          }

          return result;
        }

        // Return the configured padding between clusters.
        function getClusterOuterPadding() {
          var result = CONSTANTS.DEFAULTS.CLUSTER_OUTER_PADDING;

          if (graph.configuration.settings.clusterSettings &&
              graph.configuration.settings.clusterSettings.outerPadding !== undefined) {
            result = graph.configuration.settings.clusterSettings.outerPadding;
          }

          return result;
        }

        // The context menu to display when not right-clicking on a node.
        var canvasContextMenu = [
          {title: 'Reset Zoom/Pan', action: function(elm, d, i) { adjustZoom(); }},
          {title: 'Reset Selection', action: function(elm, d, i) { resetSelection(); }},
          {title: 'Reset Pins', action: function(elm, d, i) { resetPins(); }}
        ];

        // The context menu to display when right-clicking on a node.
        var nodeContextMenu =
            [{title: function(d) { return 'Inspect Node'; }, action: function(elm, d, i) { inspectNode(d); }}];

        // Display 'Inspect' view for this node.
        function inspectNode(d, tagName) {
          if (tagName) {
            // Clone the node.
            d = JSON.parse(JSON.stringify(d));

            if (d.metadata && d.metadata[tagName]) {
              // Prefix the tag name with asterisks so it stands out in the details view.
              d.metadata['** ' + tagName] = d.metadata[tagName];

              // Remove the non-decorated tag.
              delete d.metadata[tagName];
            }
          }

          // Add the node details into the service, to be consumed by the
          // next controller.
          inspectNodeService.setDetailData(d);

          // Redirect to the detail view page.
          $location.path('/graph/inspect');
          $rootScope.$apply();
        }

        function wheelScrollHandler() {
          var origTranslate = zoom.translate();

          zoom.translate([origTranslate[0] - window.event.deltaX, origTranslate[1] - window.event.deltaY]);
          zoomed();
        }

        function dragstarted(d) {
          d3.event.sourceEvent.stopPropagation();

          d.fixed |= CONSTANTS.FIXED_DRAGGING_BIT;
          d.dragging = true;
        }

        function dragmove(d) {
          d.dragMoved = true;
          d.px = d3.event.x, d.py = d3.event.y;
          force.start().alpha(CONSTANTS.DEFAULTS.FORCE_CLUSTERED_REFRESH_STARTING_ALPHA * 2);
        }

        function dragended(d) {
          d.fixed &= ~(CONSTANTS.FIXED_DRAGGING_BIT + CONSTANTS.FIXED_MOUSEOVER_BIT);
          d.dragging = false;
          d.dragMoved = false;
        }

        function d3_layout_forceMouseover(d) {
          // If we use Cmd-Tab but don't navigate away from this window, the keyup event won't have a chance to fire.
          // Unsetting this bit here ensures that the Pin cursor won't be displayed when mousing over a node, unless
          // the Cmd key is down.
          if (!d3.event.metaKey) {
            showPin &= ~CONSTANTS.SHOWPIN_METAKEYDOWN_BIT;
          }

          showPin |= CONSTANTS.SHOWPIN_MOUSEOVER_BIT;

          // We show the Pin cursor if the cursor is over the node and the command key is depressed.
          if (showPin === (CONSTANTS.SHOWPIN_MOUSEOVER_BIT + CONSTANTS.SHOWPIN_METAKEYDOWN_BIT)) {
            svg.attr('class', 'graph pin-cursor');
          }

          d.fixed |= CONSTANTS.FIXED_MOUSEOVER_BIT;
          d.px = d.x;
          d.py = d.y;

          // We capture the original opacity so we have a value to return to after removing the cursor from this node.
          d.origOpacity = d3.select(this).style('opacity');

          if (d.icon) {
            // Set the opacity here if the node is an icon.
            d.opacity = CONSTANTS.OPACITY_MOUSEOVER;
          } else {
            // Or if it is a circle that is already dimmed.
            if (d.origOpacity - CONSTANTS.OPACITY_DESELECTED < 0.001) {
              d.opacity = CONSTANTS.OPACITY_MOUSEOVER;
            }

            // Circles also get an outline.
            d3.select(this).style('stroke', 'black').style('stroke-width', '2').style('stroke-opacity', 0.5);
          }

          tick();
        }

        function d3_layout_forceMouseout(d) {
          showPin &= ~CONSTANTS.SHOWPIN_MOUSEOVER_BIT;
          svg.attr('class', 'graph');

          d.fixed &= ~CONSTANTS.FIXED_MOUSEOVER_BIT;

          if (d.origOpacity) {
            d.opacity = d.origOpacity;
            delete d.origOpacity;

            // Remove any outline.
            d3.select(this).style('stroke', '');
          }

          tick();
        }

        // Resize the svg element in response to the window resizing.
        function windowWasResized() { autosizeSVG(d3, true); }

        // Apply all cached settings to nodes, giving precedence to properties explicitly specified in the view model.
        // Return true if the given node has neither a specified nor cached position. Return false otherwise.
        function applyCachedSettingsToNodes(n, selectedNodeSet) {
          var noSpecifiedOrCachedPosition = false;
          var cachedSettings;

          if (n.id) {
            cachedSettings = nodeSettingsCache[n.id];
          }

          if (n.fixed) {
            // If view model specifies node is fixed, it's fixed.
            n.fixed = CONSTANTS.FIXED_PINNED_BIT;
          } else if (cachedSettings && cachedSettings.fixed) {
            // Otherwise, take into account the fixed property from the cache.
            n.fixed = CONSTANTS.FIXED_PINNED_BIT;
          }

          if (n.position) {
            // If view model specifies position use that as the starting position.
            n.x = n.position[0];
            n.y = n.position[1];

            noSpecifiedOrCachedPosition = true;
          } else if (cachedSettings) {
            // Otherwise, take into account the position from the cache.
            var cachedPosition = cachedSettings.position;

            if (cachedPosition) {
              n.x = cachedPosition[0];
              n.y = cachedPosition[1];
            }
          }

          // If we have neither a view model specified position, nor a cached position, use a random starting position
          // within some radius of the canvas center.
          if (!n.x && !n.y) {
            var radius = graph.nodes.length * 3;
            var startingPosition = d3UtilitiesService.getRandomStartingPosition(radius);

            n.x = center[0] + startingPosition[0];
            n.y = center[1] + startingPosition[1];

            noSpecifiedOrCachedPosition = true;
          }

          // Build up a set of nodes the view model specifies are to be selected.
          if (n.selected && n.id !== 'undefined') {
            selectedNodeSet.add({id: n.id});
          }

          return noSpecifiedOrCachedPosition;
        }
      }

      // Get or set the directive element. Returns the rendering service when acting as a setter.
      graph.directiveElement = function(newDirectiveElement) {
        if (!arguments.length) return directiveElement;
        directiveElement = newDirectiveElement;

        return this;
      };

      // Get or set the controller scope. Returns the rendering service when acting as a setter.
      graph.controllerScope = function(newControllerScope) {
        if (!arguments.length) return controllerScope;
        controllerScope = newControllerScope;

        return this;
      };

      // Return the dimensions of the parent container.
      graph.getParentContainerDimensions = function() { return getParentContainerDimensions(window.d3); };

      // Get or set the size of the svg element. Returns the rendering service when acting as a setter.
      graph.graphSize = function(newGraphSize) {
        if (!arguments.length) {
          var svg = window.d3.select(directiveElement)
                        .select('svg')

                            return [parseInt(svg.attr('width')), parseInt(svg.attr('height'))];
        } else {
          resizeSVG(window.d3, newGraphSize);

          return this;
        }
      };

      // Get or set the node selection. Returns the rendering service when acting as a setter.
      graph.nodeSelection = function(newNodeSelection) {
        if (!arguments.length) return selection.nodes;
        selection.nodes = newNodeSelection;

        selectEdgesInScope();

        applySelectionToOpacity();

        return this;
      };

      // Get or set the edge selection. Returns the rendering service when acting as a setter.
      graph.edgeSelection = function(newEdgeSelection) {
        if (!arguments.length) return selection.edges;
        selection.edges = newEdgeSelection;

        return this;
      };

      // Get or set the edgelabels selection. Returns the rendering service when acting as a setter.
      graph.edgelabelsSelection = function(newEdgelabelsSelection) {
        if (!arguments.length) return selection.edgelabels;
        selection.edgelabels = newEdgelabelsSelection;

        return this;
      };

      // Toggle the pinned state of this node.
      function togglePinned(d) {
        if (!nodeSettingsCache[d.id]) {
          nodeSettingsCache[d.id] = {};
        }

        if (d.fixed & CONSTANTS.FIXED_PINNED_BIT) {
          d.fixed &= ~CONSTANTS.FIXED_PINNED_BIT;
          force.start().alpha(CONSTANTS.DEFAULTS.FORCE_CLUSTERED_REFRESH_STARTING_ALPHA * 2);

          nodeSettingsCache[d.id].fixed = false;
        } else {
          d.fixed |= CONSTANTS.FIXED_PINNED_BIT;

          nodeSettingsCache[d.id].fixed = true;
          tick();
        }
      }
      graph.togglePinned = togglePinned;

      // Clear all pinned nodes.
      function resetPins() {
        node.each(function(d) {
          // Unset the appropriate bit on each node.
          d.fixed &= ~CONSTANTS.FIXED_PINNED_BIT;

          // Ensure the node is not marked in the cache as fixed.
          if (nodeSettingsCache[d.id]) {
            nodeSettingsCache[d.id].fixed = false;
          }
        });

        force.start().alpha(0.01);
      }
      graph.resetPins = resetPins;

      function tick(e) {
        var forceAlpha = force.alpha();

        node.style('opacity', function(e) {
          if (e.opacity) {
            var opacity = e.opacity;

            delete e.opacity;

            return opacity;
          }

          return window.d3.select(this).style('opacity');
        });

        if (controllerScope.viewModelService.viewModel.data.configuration.settings.clustered) {
          circle.each(d3UtilitiesService.cluster(builtClusters, 10 * forceAlpha * forceAlpha))
              .each(d3UtilitiesService.collide(d3, controllerScope.viewModelService.viewModel.data.nodes,
                                               builtClusters, .5, clusterInnerPadding, clusterOuterPadding));

          image.each(d3UtilitiesService.cluster(builtClusters, 10 * forceAlpha * forceAlpha))
              .each(d3UtilitiesService.collide(d3, controllerScope.viewModelService.viewModel.data.nodes,
                                               builtClusters, .5, clusterInnerPadding, clusterOuterPadding));
        } else {
          link.attr('x1',
                    function(d) {
                      var offsetX = d.source.icon ? d.source.size[0] / 2 : 0;

                      return d.source.x + offsetX;
                    })
              .attr('y1',
                    function(d) {
                      var offsetY = d.source.icon ? d.source.size[1] / 2 : 0;

                      return d.source.y + offsetY;
                    })
              .attr('x2',
                    function(d) {
                      var offsetX = d.target.icon ? d.target.size[0] / 2 : 0;

                      return d.target.x + offsetX;
                    })
              .attr('y2', function(d) {
                var offsetY = d.target.icon ? d.target.size[1] / 2 : 0;

                return d.target.y + offsetY;
              });

          if (edgepaths) {
            edgepaths.attr('d', function(d) {
              var path = 'M ' + d.source.x + ' ' + d.source.y + ' L ' + d.target.x + ' ' + d.target.y;
              return path
            });

            edgelabels.attr('transform', function(d, i) {
              if (d.target.x < d.source.x) {
                var bbox = this.getBBox();
                var rx = bbox.x + bbox.width / 2;
                var ry = bbox.y + bbox.height / 2;

                return 'rotate(180 ' + rx + ' ' + ry + ')';
              } else {
                return 'rotate(0)';
              }
            });
          }
        }

        circle.attr('cx', function(d) { return d.x; }).attr('cy', function(d) { return d.y; });

        image.each(function(e) {
          var singleImage = window.d3.select(this);
          var siblingText = window.d3.select(this.parentNode).select('text');
          var bbox = siblingText[0][0] ? siblingText[0][0].getBBox() : {width: 0};
          var isPinIcon = singleImage.attr('xlink:href') === '/components/graph/img/Pin.svg';

          singleImage.attr('display', function(d) {
            if (isPinIcon) {
              return d.fixed & CONSTANTS.FIXED_PINNED_BIT ? '' : 'none';
            } else {
              return '';
            }
          });

          singleImage.attr('x',
                           function(d) {
                             if (isPinIcon) {
                               if (siblingText.text() !== '') {
                                 return d.x + bbox.width + 12;
                               } else {
                                 return d.x - 5;
                               }
                             } else {
                               return d.x
                             }
                           })
              .attr('y', function(d) {
                if (isPinIcon) {
                  return d.y - 5;
                } else {
                  return d.y;
                }
              });
        });

        if (forceAlpha < 0.04) {
          controllerScope.viewModelService.viewModel.data.nodes.forEach(function(n) {
            if (n.id) {
              if (!nodeSettingsCache[n.id]) {
                nodeSettingsCache[n.id] = {};
              }

              nodeSettingsCache[n.id].position = [n.x, n.y];
            }
          });
        }

        window.d3.selectAll('text').attr('x', function(d) { return d.x; }).attr('y', function(d) { return d.y; });
      }

      // Get or set the node settings cache. Returns the rendering service when acting as a setter.
      graph.nodeSettingsCache = function(newNodeSettingsCache) {
        if (!arguments.length) return nodeSettingsCache;
        nodeSettingsCache = newNodeSettingsCache;

        return this;
      };

      // Get or set the view settings cache. Returns the rendering service when acting as a setter.
      graph.viewSettingsCache = function(newViewSettingsCache) {
        if (!arguments.length) return viewSettingsCache;
        viewSettingsCache = newViewSettingsCache;

        return this;
      };

      function zoomed() {
        var translate = zoom.translate();
        var scale = zoom.scale();

        g.attr('transform', 'translate(' + translate + ')scale(' + scale + ')');

        viewSettingsCache.translate = translate;
        viewSettingsCache.scale = scale;
      }

      function adjustZoom(factor) {
        var scale = zoom.scale(), extent = zoom.scaleExtent(), translate = zoom.translate(), x = translate[0],
            y = translate[1], target_scale = scale * factor;

        var reset = !factor;

        if (reset) {
          target_scale = 1;
          factor = target_scale / scale;
        }

        // If we're already at an extent, done.
        if (target_scale === extent[0] || target_scale === extent[1]) {
          return false;
        }
        // If the factor is too much, scale it down to reach the extent exactly.
        var clamped_target_scale = Math.max(extent[0], Math.min(extent[1], target_scale));
        if (clamped_target_scale != target_scale) {
          target_scale = clamped_target_scale;
          factor = target_scale / scale;
        }

        // Center each vector, stretch, then put back.
        x = (x - center[0]) * factor + center[0];
        y = (y - center[1]) * factor + center[1];

        if (reset) {
          x = 0;
          y = 0;
        }

        // Transition to the new view over 350ms
        window.d3.transition().duration(350).tween('zoom', function() {
          var interpolate_scale = window.d3.interpolate(scale, target_scale);
          var interpolate_trans = window.d3.interpolate(translate, [x, y]);

          return function(t) {
            zoom.scale(interpolate_scale(t)).translate(interpolate_trans(t));

            zoomed();
          };
        });
      }
      graph.adjustZoom = adjustZoom;

      return graph;
    }

    return {rendering: rendering};
  };

  angular.module('kubernetesApp.components.graph.services.d3.rendering', [])
      .service('d3RenderingService',
               ['lodash', 'd3UtilitiesService', '$location', '$rootScope', 'inspectNodeService', d3RenderingService]);

})();

/**
 Copyright 2015 Google Inc. All rights reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**=========================================================
 * Module: Graph
 * Visualizer for force directed graph.
 * This is a service that provides stateless utility
 * functions for use by the d3 visualization directive.
 =========================================================*/

(function() {
  'use strict';

  var d3UtilitiesService = function() {
    // Return a random position [x,y] within radius of the origin.
    function getRandomStartingPosition(radius) {
      var t = 2 * Math.PI * Math.random();
      var u = Math.random() + Math.random();
      var r = u > 1 ? 2 - u : u;

      return [r * Math.cos(t) * radius, r * Math.sin(t) * radius];
    }

    // This function looks up whether a pair of nodes are neighbours.
    function neighboring(a, b, linkedByIndex, selectionHops) {
      // TODO(duftler): Add support for > 1 hops.
      if (selectionHops) {
        return linkedByIndex[a.index + ',' + b.index];
      } else {
        return false;
      }
    }

    // Match on Set.has() or id.
    function setHas(searchSet, item) {
      if (searchSet.has(item)) {
        return true;
      }

      var found = false;

      searchSet.forEach(function(e) {
        if (e.id !== undefined && e.id === item.id) {
          found = true;
          return;
        }
      });

      return found;
    }

    // Returns an object containing:
    //   clusters:  An array where each index is a cluster number and the value stored at that index is the node with
    //              the maximum radius in that cluster.
    //   maxRadius: The maximum radius of all the nodes.
    //
    function buildClusters(nodes) {
      var maxRadius = -1;
      var maxCluster = -1;

      nodes.forEach(function(d) {
        maxCluster = Math.max(maxCluster, d.cluster);
        maxRadius = Math.max(maxRadius, d.radius);
      });

      var clusters = new Array(maxCluster + 1);

      nodes.forEach(function(d) {
        if (!clusters[d.cluster] || (d.radius > clusters[d.cluster].radius)) {
          clusters[d.cluster] = d;
        }
      });

      return {clusters: clusters, maxRadius: maxRadius};
    }

    // Move d to be adjacent to the cluster node.
    function cluster(builtClusters, alpha) {
      return function(d) {
        var cluster = builtClusters.clusters[d.cluster];
        if (cluster === d) return;
        if (d.x == cluster.x && d.y == cluster.y) {
          d.x += 0.1;
        }
        var x = d.x - cluster.x, y = d.y - cluster.y, l = Math.sqrt(x * x + y * y), r = d.radius + cluster.radius;
        if (l != r) {
          l = (l - r) / l * alpha;
          d.x -= x *= l;
          d.y -= y *= l;
          cluster.x += x;
          cluster.y += y;
        }
      };
    }

    // Resolves collisions between d and all other nodes.
    function collide(d3, nodes, builtClusters, alpha, clusterInnerPadding, clusterOuterPadding) {
      var quadtree = d3.geom.quadtree(nodes);
      return function(d) {
        var r = d.radius + builtClusters.maxRadius + Math.max(clusterInnerPadding, clusterOuterPadding), nx1 = d.x - r,
            nx2 = d.x + r, ny1 = d.y - r, ny2 = d.y + r;
        quadtree.visit(function(quad, x1, y1, x2, y2) {
          if (quad.point && (quad.point !== d)) {
            var x = d.x - quad.point.x, y = d.y - quad.point.y, l = Math.sqrt(x * x + y * y),
                r = d.radius + quad.point.radius +
                    (d.cluster === quad.point.cluster ? clusterInnerPadding : clusterOuterPadding);
            if (l < r) {
              l = (l - r) / l * alpha;
              d.x -= x *= l;
              d.y -= y *= l;
              quad.point.x += x;
              quad.point.y += y;
            }
          }
          return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
        });
      };
    }

    function showContextMenu(d3, data, index, contextMenu) {
      var elm = this;

      d3.selectAll('.d3-context-menu').html('');
      var list = d3.selectAll('.d3-context-menu').append('ul');
      list.selectAll('li')
          .data(contextMenu)
          .enter()
          .append('li')
          .html(function(d) { return (typeof d.title === 'string') ? d.title : d.title(data); })
          .on('click', function(d, i) {
            d.action(elm, data, index);
            d3.select('.d3-context-menu').style('display', 'none');
          });

      // Display context menu.
      d3.select('.d3-context-menu')
          .style('left', (d3.event.pageX - 2) + 'px')
          .style('top', (d3.event.pageY - 2) + 'px')
          .style('display', 'block')
          .on('contextmenu', function() { d3.event.preventDefault(); });

      d3.event.preventDefault();
    }

    return {
      'getRandomStartingPosition': getRandomStartingPosition,
      'neighboring': neighboring,
      'setHas': setHas,
      'buildClusters': buildClusters,
      'cluster': cluster,
      'collide': collide,
      'showContextMenu': showContextMenu
    };
  };

  angular.module('kubernetesApp.components.graph.services.d3', []).service('d3UtilitiesService', [d3UtilitiesService]);

})();

/**
 Copyright 2015 Google Inc. All rights reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**=========================================================
 * Module: Graph
 * Visualizer for force directed graph
 * This is a service that shares node detals data among controllers.
 =========================================================*/

(function() {
  'use strict';

  var inspectNodeService = function() {
    var nodeDetails = null;
    var setDetailData = function(data) { nodeDetails = data; };

    var getDetailData = function() { return nodeDetails; };

    return {
      'setDetailData': setDetailData,
      'getDetailData': getDetailData
    };
  };

  angular.module('kubernetesApp.components.graph.services', []).factory('inspectNodeService', inspectNodeService);

})();

/**
 Copyright 2015 Google Inc. All rights reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**=========================================================
 * Module: Graph
 * Visualizer for force directed graph
 =========================================================*/

(function() {
  "use strict";

  // Compute the view model based on the data model and control parameters
  // and place the result in the current scope at $scope.viewModel.
  var viewModelService = function ViewModelService(_) {
    var defaultConfiguration = {
      "legend": undefined,
      "settings": {"clustered": false, "showEdgeLabels": false, "showNodeLabels": true},
      "selectionHops": 1,
      "selectionIdList": []
    };

    var defaultData = {
      "configuration": defaultConfiguration,
      "nodes": [{"name": "no data", "radius": 10, "fill": "cornflowerblue"}],
      "links": []
    };

    var viewModel = {
      "data": defaultData,
      "default": defaultData,
      "version": 0,
      "transformNames": []
    };

    var getLegend = function() {
      return (viewModel && viewModel.data && viewModel.data.configuration) ? viewModel.data.configuration.legend :
                                                                             undefined;
    };

    var setLegend = function(legend) {
      if (viewModel && viewModel.data && viewModel.data.configuration) {
        viewModel.data.configuration.legend = legend;
      }
    };

    var getSettings = function() {
      return (viewModel && viewModel.data && viewModel.data.configuration) ? viewModel.data.configuration.settings :
                                                                             undefined;
    };

    var setSettings = function(settings) {
      if (viewModel && viewModel.data && viewModel.data.configuration) {
        viewModel.data.configuration.settings = settings;
      }
    };

    var getSelectionHops = function() {
      return (viewModel && viewModel.data && viewModel.data.configuration) ?
                 viewModel.data.configuration.selectionHops :
                 1;
    };

    var setSelectionHops = function(selectionHops) {
      if (viewModel && viewModel.data && viewModel.data.configuration) {
        viewModel.data.configuration.selectionHops = selectionHops;
      }
    };

    var getSelectionIdList = function() {
      return (viewModel && viewModel.data && viewModel.data.configuration) ?
                 viewModel.data.configuration.selectionIdList :
                 [];
    };

    var setSelectionIdList = function(selectionIdList) {
      if (viewModel && viewModel.data && viewModel.data.configuration) {
        viewModel.data.configuration.selectionIdList = selectionIdList;
      }
    };

    // Load the default legend.
    (function() {
      $.getJSON("components/graph/assets/legend.json")
          .done(function(legend) { defaultData.configuration.legend = legend; })
          .fail(function(jqxhr, settings, exception) {
            console.log('ERROR: Could not load default legend: ' + exception);
          });
    }());

    var defaultTransformName = undefined;
    var transformsByName = {};

    // Load transforms.
    (function() {
      var stripSuffix = function(fileName) {
        var suffixIndex = fileName.indexOf(".");
        if (suffixIndex > 0) {
          fileName = fileName.substring(0, suffixIndex);
        }

        return fileName;
      };

      var getConstructor = function(constructorName) { return window[constructorName]; };

      var bindTransform = function(constructorName, directoryEntry) {
        var constructor = getConstructor(constructorName);
        if (constructor) {
          var transform = constructor(_, directoryEntry.data);
          if (transform) {
            if (!defaultTransformName) {
              defaultTransformName = directoryEntry.name;
            }

            viewModel.transformNames.push(directoryEntry.name);
            transformsByName[directoryEntry.name] = transform;
            return;
          }
        }

        console.log('ERROR: Could not bind transform "' + directoryEntry.name + '".');
      };

      // Load a transform from a given directory entry.
      var loadTransform = function(directoryEntry) {
        if (directoryEntry && directoryEntry.name && directoryEntry.script) {
          var constructorName = stripSuffix(directoryEntry.script);
          if (!getConstructor(constructorName)) {
            // Load the script into the window scope.
            var scriptPath = "components/graph/assets/transforms/" + directoryEntry.script;
            $.getScript(scriptPath)
                .done(function() {
                  // Defer to give the load opportunity to complete.
                  _.defer(function() { bindTransform(constructorName, directoryEntry); });
                })
                .fail(function(jqxhr, settings, exception) {
                  console.log('ERROR: Could not load transform "' + directoryEntry.name + '": ' + exception);
                });
          } else {
            bindTransform(constructorName, directoryEntry);
          }
        }
      };

      // Load the transform directory
      $.getJSON("components/graph/assets/transforms.json")
          .done(function(transforms) {
            // Defer to give the load opportunity to complete.
            _.defer(function() {
              if (transforms.directory) {
                _.forEach(transforms.directory, function(directoryEntry) { loadTransform(directoryEntry); });
              }
            });
          })
          .fail(function(jqxhr, settings, exception) {
            console.log('ERROR: Could not load transform directory: ' + exception);
          });
    }());

    var setViewModel = function(data) {
      if (data && data.nodes && data.configuration && data.configuration.settings) {
        viewModel.data = data;
        viewModel.version++;
      }
    };

    // Generate the view model from a given data model using a given transform.
    var generateViewModel = function(fromData, transformName) {
      var initializeConfiguration = function(toData) {
        var initializeLegend = function(fromConfiguration, toConfiguration) {
          var toLegend = toConfiguration.legend;
          var fromLegend = fromConfiguration.legend;
          if (!toLegend) {
            toConfiguration.legend = JSON.parse(JSON.stringify(fromLegend));
          } else {
            if (!toLegend.nodes) {
              toLegend.nodes = JSON.parse(JSON.stringify(fromLegend.nodes));
            }

            if (!toLegend.links) {
              toLegend.links = JSON.parse(JSON.stringify(fromLegend.links));
            }
          }
        };

        var initializeSettings = function(fromConfiguration, toConfiguration) {
          if (!toConfiguration.settings) {
            toConfiguration.settings = JSON.parse(JSON.stringify(fromConfiguration.settings));
          }
        };

        var initializeSelection = function(fromConfiguration, toConfiguration) {
          if (!toConfiguration.selectionHops) {
            toConfiguration.selectionHops = fromConfiguration.selectionHops;
          }

          if (!toConfiguration.selectionIdList) {
            toConfiguration.selectionIdList = fromConfiguration.selectionIdList;
          }
        };

        var toConfiguration = toData.configuration;
        var fromConfiguration = viewModel.data.configuration;

        if (!toConfiguration) {
          toData.configuration = JSON.parse(JSON.stringify(fromConfiguration));
        } else {
          initializeLegend(fromConfiguration, toConfiguration);
          initializeSettings(fromConfiguration, toConfiguration);
          initializeSelection(fromConfiguration, toConfiguration);
        }
      };

      var processNodes = function(toData) {
        var typeToCluster = {};
        var idToIndex = {};

        var setIndex = function(toNode, idToIndex) {
          if (!idToIndex[toNode.id]) {
            idToIndex[toNode.id] = _.keys(idToIndex).length;
          }
        };

        var setCluster = function(toNode, typeToCluster) {
          if (toNode.type) {
            toNode.cluster = typeToCluster[toNode.type];
            if (toNode.cluster === undefined) {
              toNode.cluster = _.keys(typeToCluster).length;
              typeToCluster[toNode.type] = toNode.cluster;
            }
          } else {
            toNode.cluster = 0;
          }
        };

        var setStyle = function(toItem, entries) {
          if (toItem.type && entries[toItem.type]) {
            _.assign(toItem, entries[toItem.type].style);
            entries[toItem.type].available = true;
          } else {
            toItem.type = undefined;
          }
        };

        var processLinks = function(toData, legend, filtered) {
          var getIndex = function(toLink, idToIndex) {
            if (toLink.source && toLink.target) {
              toLink.source = idToIndex[toLink.source];
              toLink.target = idToIndex[toLink.target];
            }
          };

          var chain = _.chain(toData.links)
                          .forEach(function(toLink) {
                            setStyle(toLink, legend.links);
                            if (toLink.type) {
                              getIndex(toLink, idToIndex);
                            }
                          });

          chain = chain.filter("type");
          if (filtered) {
            chain = chain.filter(function(toLink) {
              return (toLink.source !== undefined) && (toLink.target !== undefined);
            });
          }

          toData.links = chain.value();
        };

        var configuration = toData.configuration;
        var legend = configuration.legend;
        var settings = configuration.settings;

        _.forOwn(legend.nodes, function(nodeEntry) { nodeEntry.available = false; });

        var chain = _.chain(toData.nodes).forEach(function(toNode) { setStyle(toNode, legend.nodes); });

        var filtered = _.any(legend.nodes, function(nodeEntry) { return !nodeEntry.selected; });

        chain = chain.filter("type");
        if (filtered) {
          chain = chain.filter(function(toNode) {
            return legend.nodes[toNode.type] ? legend.nodes[toNode.type].selected : false;
          });
        }

        if (settings && settings.clustered) {
          chain = chain.forEach(function(toNode) { setCluster(toNode, typeToCluster); });
        }

        toData.nodes = chain.forEach(function(toNode) { setIndex(toNode, idToIndex); }).value();

        if (toData.links) {
          processLinks(toData, legend, filtered);
        }
      };

      if (fromData && transformName) {
        var transform = transformsByName[transformName];
        if (transform) {
          var configuration = JSON.parse(JSON.stringify(viewModel.data.configuration));
          var toData = transform(fromData, configuration);
          if (toData.nodes) {
            initializeConfiguration(toData);
            processNodes(toData);
          } else {
            toData.configuration = configuration;
            toData.nodes = defaultData.nodes;
            toData.links = defaultData.links;
          }

          setViewModel(toData);
        } else {
          console.log('ERROR: Could not find transform "' + transformName + '".');
        }
      }
    };

    this.$get = function() {
      return {
        "viewModel": viewModel,
        "getLegend": getLegend,
        "setLegend": setLegend,
        "getSettings": getSettings,
        "setSettings": setSettings,
        "getSelectionIdList": getSelectionIdList,
        "setSelectionIdList": setSelectionIdList,
        "getSelectionHops": getSelectionHops,
        "setSelectionHops": setSelectionHops,
        "defaultTransformName": defaultTransformName,
        "generateViewModel": generateViewModel,
        "setViewModel": setViewModel
      };
    };
  };

  angular.module("kubernetesApp.components.graph").provider("viewModelService", ["lodash", viewModelService]);
}());
